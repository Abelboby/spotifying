import 'package:flutter/material.dart';
import 'dart:convert';
// import 'dart:math';
import 'package:http/http.dart' as http;
import 'package:firebase_core/firebase_core.dart';
import 'package:cloud_firestore/cloud_firestore.dart';
import 'package:flutter_sms_inbox/flutter_sms_inbox.dart';
import 'package:permission_handler/permission_handler.dart';
import 'firebase_options.dart'; // Generated by FlutterFire CLI

void main() async {
  WidgetsFlutterBinding.ensureInitialized();
  await Firebase.initializeApp(
    options: DefaultFirebaseOptions.currentPlatform,
  );
  runApp(const MyApp());
}

class MyApp extends StatelessWidget {
  const MyApp({super.key});

  @override
  Widget build(BuildContext context) {
    return MaterialApp(
      debugShowCheckedModeBanner: false,
      theme: ThemeData(
        colorScheme: ColorScheme.fromSeed(
          seedColor: Colors.blue,
          brightness: Brightness.light,
        ),
        useMaterial3: true,
        cardTheme: const CardTheme(
          elevation: 2,
          margin: EdgeInsets.symmetric(horizontal: 16, vertical: 8),
        ),
      ),
      home: const SmsPermissionWrapper(),
    );
  }
}

class SmsPermissionWrapper extends StatefulWidget {
  const SmsPermissionWrapper({super.key});

  @override
  State<SmsPermissionWrapper> createState() => _SmsPermissionWrapperState();
}

class _SmsPermissionWrapperState extends State<SmsPermissionWrapper> {
  bool _permissionChecked = false;
  bool _hasPermission = false;

  @override
  void initState() {
    super.initState();
    _checkPermission();
  }

  Future<void> _checkPermission() async {
    final status = await Permission.sms.status;
    setState(() {
      _hasPermission = status.isGranted;
      _permissionChecked = true;
    });

    if (!_hasPermission) {
      _showPermissionDialog();
    }
  }

  Future<void> _requestPermission() async {
    final status = await Permission.sms.request();
    setState(() {
      _hasPermission = status.isGranted;
    });
  }

  void _showPermissionDialog() {
    showDialog(
      context: context,
      barrierDismissible: false,
      builder: (context) => AlertDialog(
        title: const Text('SMS Permission Required'),
        content: const Text(
          'This app needs SMS permission to automatically mark payments based on bank transaction messages. Without this permission, you\'ll need to mark payments manually.',
        ),
        actions: [
          TextButton(
            onPressed: () {
              Navigator.pop(context);
            },
            child: const Text('Skip'),
          ),
          FilledButton(
            onPressed: () async {
              Navigator.pop(context);
              await _requestPermission();
            },
            child: const Text('Grant Permission'),
          ),
        ],
      ),
    );
  }

  @override
  Widget build(BuildContext context) {
    if (!_permissionChecked) {
      return const Scaffold(
        body: Center(
          child: CircularProgressIndicator(),
        ),
      );
    }

    return GroupListScreen();
  }
}

// Main screen to display and manage groups
class GroupListScreen extends StatelessWidget {
  final CollectionReference groupsCollection =
      FirebaseFirestore.instance.collection('groups1');

  @override
  Widget build(BuildContext context) {
    return Scaffold(
      appBar: AppBar(
        title: const Text('Group Management'),
        elevation: 0,
        backgroundColor: Theme.of(context).colorScheme.primaryContainer,
      ),
      body: StreamBuilder<QuerySnapshot>(
        stream: groupsCollection.snapshots(),
        builder: (context, snapshot) {
          if (snapshot.connectionState == ConnectionState.waiting) {
            return const Center(child: CircularProgressIndicator());
          }

          if (!snapshot.hasData || snapshot.data!.docs.isEmpty) {
            return Center(
              child: Column(
                mainAxisAlignment: MainAxisAlignment.center,
                children: [
                  Icon(
                    Icons.group_off,
                    size: 64,
                    color: Theme.of(context).colorScheme.secondary,
                  ),
                  const SizedBox(height: 16),
                  const Text(
                    'No Groups Found',
                    style: TextStyle(fontSize: 18),
                  ),
                ],
              ),
            );
          }

          final groups = snapshot.data!.docs;
          return ListView.builder(
            padding: const EdgeInsets.all(8),
            itemCount: groups.length,
            itemBuilder: (context, index) {
              final group = groups[index];
              return Card(
                child: ListTile(
                  contentPadding: const EdgeInsets.symmetric(
                    horizontal: 16,
                    vertical: 8,
                  ),
                  title: Text(
                    group['groupName'],
                    style: const TextStyle(
                      fontSize: 18,
                      fontWeight: FontWeight.bold,
                    ),
                  ),
                  subtitle: Text(
                    'ID: ${group.id}',
                    style: TextStyle(
                      color: Theme.of(context).colorScheme.secondary,
                    ),
                  ),
                  trailing: Row(
                    mainAxisSize: MainAxisSize.min,
                    children: [
                      IconButton(
                        icon: const Icon(Icons.edit),
                        onPressed: () => _showEditGroupDialog(context, group),
                      ),
                      IconButton(
                        icon: const Icon(Icons.delete),
                        color: Colors.red,
                        onPressed: () => group.reference.delete(),
                      ),
                    ],
                  ),
                  onTap: () async {
                    // Show loading dialog
                    showDialog(
                      context: context,
                      barrierDismissible: false,
                      builder: (BuildContext context) {
                        return const Center(
                          child: Card(
                            child: Padding(
                              padding: EdgeInsets.all(20.0),
                              child: Column(
                                mainAxisSize: MainAxisSize.min,
                                children: [
                                  CircularProgressIndicator(),
                                  SizedBox(height: 16),
                                  Text('Loading group details...'),
                                ],
                              ),
                            ),
                          ),
                        );
                      },
                    );

                    // Pre-fetch the members data
                    final membersCollection = FirebaseFirestore.instance
                        .collection('groups1')
                        .doc(group.id)
                        .collection('members');

                    try {
                      // Wait for initial data fetch
                      await membersCollection.get();

                      // Pop the loading dialog
                      Navigator.pop(context);

                      // Navigate to group details
                      Navigator.push(
                        context,
                        MaterialPageRoute(
                          builder: (context) => GroupDetailScreen(
                            groupId: group.id,
                            groupName: group['groupName'],
                          ),
                        ),
                      );
                    } catch (error) {
                      // Pop the loading dialog
                      Navigator.pop(context);

                      // Show error message
                      ScaffoldMessenger.of(context).showSnackBar(
                        SnackBar(content: Text('Error loading group: $error')),
                      );
                    }
                  },
                ),
              );
            },
          );
        },
      ),
      floatingActionButton: FloatingActionButton.extended(
        onPressed: () => _showAddGroupDialog(context),
        icon: const Icon(Icons.add),
        label: const Text('Add Group'),
      ),
    );
  }

  // Add a new group
  void _showAddGroupDialog(BuildContext context) {
    final TextEditingController groupNameController = TextEditingController();

    showDialog(
      context: context,
      builder: (context) => AlertDialog(
        shape: RoundedRectangleBorder(
          borderRadius: BorderRadius.circular(16),
        ),
        title: Row(
          children: [
            Icon(
              Icons.group_add,
              color: Theme.of(context).colorScheme.primary,
            ),
            const SizedBox(width: 8),
            const Text('Add New Group'),
          ],
        ),
        content: TextField(
          controller: groupNameController,
          decoration: InputDecoration(
            hintText: 'Group Name',
            filled: true,
            fillColor: Theme.of(context).colorScheme.surfaceVariant,
            border: OutlineInputBorder(
              borderRadius: BorderRadius.circular(8),
              borderSide: BorderSide.none,
            ),
            prefixIcon: const Icon(Icons.group),
          ),
          textCapitalization: TextCapitalization.words,
        ),
        actions: [
          TextButton(
            onPressed: () => Navigator.pop(context),
            child: const Text('Cancel'),
          ),
          FilledButton(
            onPressed: () async {
              final groupName = groupNameController.text.trim();
              if (groupName.isNotEmpty) {
                // Create the group
                final docRef =
                    await groupsCollection.add({'groupName': groupName});

                // Initialize with current month
                String currentMonth = DateTime.now().toString().substring(0, 7);

                // Create a dummy document to initialize the members collection
                await docRef.collection('members').add({
                  'name': 'Dummy',
                  'phoneNumber': '0000000000',
                  'groupId': docRef.id,
                  'payments': {currentMonth: false},
                  'forwarded': false,
                });

                Navigator.pop(context);
              }
            },
            child: const Text('Add'),
          ),
        ],
      ),
    );
  }

  // Edit an existing group
  void _showEditGroupDialog(BuildContext context, QueryDocumentSnapshot group) {
    final TextEditingController groupNameController =
        TextEditingController(text: group['groupName']);

    showDialog(
      context: context,
      builder: (context) => AlertDialog(
        title: const Text('Edit Group'),
        content: TextField(
          controller: groupNameController,
          decoration: const InputDecoration(hintText: 'Group Name'),
        ),
        actions: [
          TextButton(
            onPressed: () {
              Navigator.pop(context);
            },
            child: const Text('Cancel'),
          ),
          TextButton(
            onPressed: () {
              final groupName = groupNameController.text.trim();
              if (groupName.isNotEmpty) {
                group.reference.update({'groupName': groupName});
                Navigator.pop(context);
              }
            },
            child: const Text('Update'),
          ),
        ],
      ),
    );
  }
}

class GroupDetailScreen extends StatefulWidget {
  final String groupId;
  final String groupName;

  GroupDetailScreen({required this.groupId, required this.groupName});

  @override
  _GroupDetailScreenState createState() => _GroupDetailScreenState();
}

class _GroupDetailScreenState extends State<GroupDetailScreen> {
  String? selectedMonth;
  List<String> availableMonths = [];
  late CollectionReference membersCollection;
  List<String> pendingMembersMap = [];
  bool isLoading = false;
  bool isInitializing = true;
  final SmsQuery _smsQuery = SmsQuery();
  bool _hasSmsPermission = false;

  @override
  void initState() {
    super.initState();
    membersCollection = FirebaseFirestore.instance
        .collection('groups1')
        .doc(widget.groupId)
        .collection('members');
    _initializeData();
    _requestSmsPermission();
  }

  Future<void> _requestSmsPermission() async {
    try {
      print('\nRequesting SMS permissions...');
      final status = await Permission.sms.status;
      print('Current SMS permission status: ${status.toString()}');

      if (status.isDenied) {
        print('SMS permission is denied, requesting...');
        final result = await Permission.sms.request();
        print('SMS permission request result: ${result.toString()}');
        setState(() {
          _hasSmsPermission = result.isGranted;
        });
      } else if (status.isPermanentlyDenied) {
        print('SMS permission is permanently denied, opening settings...');
        await openAppSettings();
      } else {
        print('SMS permission is already granted');
        setState(() {
          _hasSmsPermission = true;
        });
      }
    } catch (e) {
      print('Error requesting SMS permission: $e');
    }
  }

  Future<void> _initializeData() async {
    try {
      await _fetchAvailableMonths();
      await _fetchPendingMembers();

      // Set current month as default if not selected
      if (selectedMonth == null && availableMonths.isNotEmpty) {
        final now = DateTime.now();
        final currentMonth =
            '${now.year}-${now.month.toString().padLeft(2, '0')}';
        if (availableMonths.contains(currentMonth)) {
          selectedMonth = currentMonth;
        } else {
          selectedMonth = availableMonths.last;
        }
      }

      // Run automatic payment marking
      if (selectedMonth != null) {
        await processAutomaticPayments();
      }
    } finally {
      if (mounted) {
        setState(() {
          isInitializing = false;
        });
      }
    }
  }

  Future<void> _fetchPendingMembers() async {
    if (selectedMonth == null) return;

    final snapshot = await membersCollection
        .where('payments.$selectedMonth', isEqualTo: false)
        .get();

    setState(() {
      pendingMembersMap = snapshot.docs
          .map((doc) => doc['phoneNumber'] as String)
          .toSet() // Remove duplicates
          .toList();

      print('Pending Members Updated: $pendingMembersMap');
    });
  }

  Future<void> _fetchAvailableMonths() async {
    QuerySnapshot snapshot = await membersCollection.get();
    final allMonths = <String>{};

    if (snapshot.docs.isEmpty) {
      // If no members exist, initialize with current month
      String currentMonth = DateTime.now().toString().substring(0, 7);
      allMonths.add(currentMonth);
    } else {
      for (var member in snapshot.docs) {
        final payments = member['payments'] ?? {};
        allMonths.addAll(payments.keys.cast<String>());
      }
    }

    if (mounted) {
      setState(() {
        availableMonths = allMonths.toList()..sort();
        String currentMonth = DateTime.now().toString().substring(0, 7);
        selectedMonth = availableMonths.isNotEmpty
            ? availableMonths.contains(currentMonth)
                ? currentMonth
                : availableMonths.last
            : currentMonth;
      });
    }
  }

  // Method to calculate the next month based on the current one
  String _getNextMonth(String latestMonth) {
    List<String> parts = latestMonth.split('-');
    int year = int.parse(parts[0]);
    int month = int.parse(parts[1]);

    if (month == 12) {
      year += 1;
      month = 1;
    } else {
      month += 1;
    }

    return "$year-${month.toString().padLeft(2, '0')}";
  }

  // Add new month to all members
  void _addNewMonth() async {
    if (availableMonths.isEmpty) {
      // If this is a new group with no months, initialize with current month
      String currentMonth = DateTime.now().toString().substring(0, 7);
      String newMonth = currentMonth;
      await _initializeNewGroup(newMonth);
    } else {
      // Get the latest month and calculate next month
      String latestMonth = availableMonths.last;
      String newMonth = _getNextMonth(latestMonth);

      // Get all groups
      final groupsCollection = FirebaseFirestore.instance.collection('groups1');
      final groups = await groupsCollection.get();

      // Update all groups
      for (var group in groups.docs) {
        final membersRef = group.reference.collection('members');
        final members = await membersRef.get();

        // Update all members in this group
        for (var member in members.docs) {
          await membersRef.doc(member.id).update({
            'payments.$newMonth': false,
          });
        }
      }

      // Update UI
      setState(() {
        availableMonths.add(newMonth);
        selectedMonth = newMonth;
      });
    }
  }

  // New method to initialize a new group
  Future<void> _initializeNewGroup(String initialMonth) async {
    setState(() {
      availableMonths = [initialMonth];
      selectedMonth = initialMonth;
    });
  }

  Future<void> sendPostRequest(String endpoint,
      {Map<String, dynamic>? body}) async {
    try {
      final url =
          Uri.parse("https://nodejs-test-hosting.onrender.com/$endpoint");
      final response = await http.post(
        url,
        headers: {
          'Content-Type': 'application/json',
        },
        body: body != null ? jsonEncode(body) : null,
      );

      if (response.statusCode == 200) {
        _showSnackBar("Success: ${response.body}");
      } else {
        _showSnackBar("Error: ${response.statusCode} - ${response.body}");
      }
    } catch (e) {
      _showSnackBar("Error: $e");
    }
  }

  Future<void> _mentionPendingUsers() async {
    // Fetch latest pending members before proceeding
    await _fetchPendingMembers();

    if (pendingMembersMap.isEmpty) {
      _showSnackBar('No pending users to mention');
      return;
    }

    setState(() {
      isLoading = true;
    });

    try {
      // Find a pending member to get their groupId
      final pendingMember = await membersCollection
          .where('phoneNumber', whereIn: pendingMembersMap)
          .where('payments.$selectedMonth', isEqualTo: false)
          .limit(1)
          .get();

      if (pendingMember.docs.isEmpty) {
        throw Exception('No pending members found');
      }

      final String memberGroupId = pendingMember.docs.first['groupId'];
      final userNumbers = pendingMembersMap
          .map((phone) => phone.replaceAll(RegExp(r'\D'), ''))
          .toList();

      await sendPostRequest(
        "mention-users",
        body: {
          "groupId": memberGroupId,
          "userNumbers": userNumbers,
          "messageType": "pending",
        },
      );
    } catch (error) {
      _showSnackBar('Error mentioning users: ${error.toString()}');
    } finally {
      setState(() {
        isLoading = false;
      });
    }
  }

  Future<void> _mentionPaidUsers() async {
    if (isLoading) return;

    setState(() {
      isLoading = true;
    });

    try {
      // Get paid members who haven't been forwarded yet
      final paidMembers = await membersCollection
          .where('payments.$selectedMonth', isEqualTo: true)
          .where('forwarded', isEqualTo: false)
          .get();

      if (paidMembers.docs.isEmpty) {
        _showSnackBar('No new paid members to forward');
        return;
      }

      // Get groupId from the first member
      final String memberGroupId = paidMembers.docs.first['groupId'];

      // Extract phone numbers
      final userNumbers = paidMembers.docs
          .map((doc) => doc['phoneNumber'] as String)
          .map((phone) => phone.replaceAll(RegExp(r'\D'), ''))
          .toList();

      // Send the post request
      await sendPostRequest(
        "mention-users",
        body: {
          "groupId": memberGroupId,
          "userNumbers": userNumbers,
          "messageType": "paid",
        },
      );

      // Mark these members as forwarded
      for (var doc in paidMembers.docs) {
        await doc.reference.update({'forwarded': true});
      }

      _showSnackBar(
          'Successfully forwarded ${userNumbers.length} paid members');
    } catch (error) {
      _showSnackBar('Error forwarding paid members: ${error.toString()}');
    } finally {
      setState(() {
        isLoading = false;
      });
    }
  }

  // Show a snack bar with the response message
  void _showSnackBar(String message) {
    ScaffoldMessenger.of(context).showSnackBar(
      SnackBar(content: Text(message)),
    );
  }

  // Add this method to process SMS messages
  Future<void> processAutomaticPayments() async {
    if (!_hasSmsPermission) {
      _showSnackBar(
          'SMS permission is required to process payments automatically');
      await _requestSmsPermission();
      if (!_hasSmsPermission) return;
    }

    if (selectedMonth == null) {
      _showSnackBar('Please select a month first');
      return;
    }

    setState(() {
      isLoading = true;
    });

    try {
      print('\n=== Starting SMS Processing ===');

      // Get all messages first
      final messages = await _smsQuery.querySms(
        kinds: [SmsQueryKind.inbox],
      );

      print('Total messages found: ${messages.length}');

      // Filter for SBI UPI messages
      final sbiMessages = messages
          .where((msg) => (msg.address ?? '').toUpperCase().contains('SBIUPI'))
          .toList();

      print('SBI UPI messages found: ${sbiMessages.length}');

      // Get pending members
      final pendingMembers = await membersCollection
          .where('payments.$selectedMonth', isEqualTo: false)
          .get();

      print('Pending members found: ${pendingMembers.docs.length}');

      int markedCount = 0;
      List<String> processedMembers = [];

      // Process each message
      for (var message in sbiMessages) {
        if (message.body == null) continue;

        print('\nProcessing message: ${message.body}');

        // Extract date and amount from message
        final RegExp dateRegex =
            RegExp(r'on (\d{2})([A-Za-z]{3})(\d{2})', caseSensitive: false);
        final RegExp amountRegex =
            RegExp(r'Rs\.?(\d+(?:\.\d{1,2})?)', caseSensitive: false);
        final RegExp senderRegex = RegExp(
            r'(?:from|by) ([A-Za-z\s]+)(?=\s+(?:Ref|UPI|on|$))',
            caseSensitive: false);

        final dateMatch = dateRegex.firstMatch(message.body!);
        final amountMatch = amountRegex.firstMatch(message.body!);
        final senderMatch = senderRegex.firstMatch(message.body!);

        if (dateMatch == null || amountMatch == null || senderMatch == null) {
          print('Skipping message - Missing required information');
          continue;
        }

        final day = dateMatch.group(1);
        final monthStr = dateMatch.group(2)?.toLowerCase();
        final year = dateMatch.group(3);
        final amount = amountMatch.group(1);
        final sender = senderMatch.group(1)?.trim();

        print('Extracted data:');
        print('Date: $day-$monthStr-$year');
        print('Amount: Rs.$amount');
        print('Sender: $sender');

        if (day == null || monthStr == null || year == null || sender == null) {
          print('Skipping message - Invalid data');
          continue;
        }

        // Convert month abbreviation to number
        final monthMap = {
          'jan': 1,
          'feb': 2,
          'mar': 3,
          'apr': 4,
          'may': 5,
          'jun': 6,
          'jul': 7,
          'aug': 8,
          'sep': 9,
          'oct': 10,
          'nov': 11,
          'dec': 12
        };

        final month = monthMap[monthStr];
        if (month == null) continue;

        // Format to YYYY-MM
        final fullYear = 2000 + int.parse(year);
        final messageMonth = '$fullYear-${month.toString().padLeft(2, '0')}';

        // Check if message is from selected month
        if (messageMonth != selectedMonth) {
          print(
              'Skipping message - Wrong month ($messageMonth != $selectedMonth)');
          continue;
        }

        // Check each pending member
        for (var member in pendingMembers.docs) {
          final bankingName = member['bankingName']?.toString().toLowerCase();
          if (bankingName == null || bankingName.isEmpty) {
            print('Skipping member ${member['name']} - No banking name');
            continue;
          }

          final senderLower = sender.toLowerCase();
          if (senderLower.contains(bankingName)) {
            // Check payment amount if set
            final expectedAmount = member['paymentAmount'];
            if (expectedAmount != null) {
              final transactionAmount = double.tryParse(amount ?? '0');
              if (transactionAmount == null ||
                  transactionAmount != expectedAmount) {
                print(
                    'Amount mismatch for ${member['name']}: Expected Rs.$expectedAmount, got Rs.$amount');
                continue;
              }
            }

            print('Match found! Marking ${member['name']} as paid');
            await member.reference.update({
              'payments.$selectedMonth': true,
              'forwarded': false,
            });
            markedCount++;
            processedMembers.add('${member['name']} (Rs.$amount)');
            break;
          }
        }
      }

      if (markedCount > 0) {
        _showSnackBar(
            'Marked $markedCount payments:\n${processedMembers.join("\n")}');
      } else {
        _showSnackBar('No matching transactions found');
      }
    } catch (e) {
      print('Error processing payments: $e');
      _showSnackBar('Error: $e');
    } finally {
      setState(() {
        isLoading = false;
      });
      await _fetchPendingMembers();
    }
  }

  // Add method to process a single SMS message
  Future<void> processSingleSms(SmsMessage message) async {
    if (!_hasSmsPermission || selectedMonth == null) return;

    try {
      // Parse the date from message body (format: ddMMMYY)
      final RegExp dateRegex = RegExp(r'(\d{2})([A-Za-z]{3})(\d{2})');
      final dateMatch = dateRegex.firstMatch(message.body ?? '');

      if (dateMatch == null) return;

      final day = dateMatch.group(1);
      final monthStr = dateMatch.group(2)?.toLowerCase();
      final year = dateMatch.group(3);

      if (day == null || monthStr == null || year == null) return;

      // Convert month abbreviation to number
      final monthMap = {
        'jan': 1,
        'feb': 2,
        'mar': 3,
        'apr': 4,
        'may': 5,
        'jun': 6,
        'jul': 7,
        'aug': 8,
        'sep': 9,
        'oct': 10,
        'nov': 11,
        'dec': 12
      };

      final month = monthMap[monthStr];
      if (month == null) return;

      // Convert to full year (assuming 20xx)
      final fullYear = 2000 + int.parse(year);

      // Format the date to match our month format (YYYY-MM)
      final messageMonth = '$fullYear-${month.toString().padLeft(2, '0')}';

      // Skip if message is not from the selected month
      if (messageMonth != selectedMonth) return;

      // Get pending members for this month
      final pendingMembers = await membersCollection
          .where('payments.$selectedMonth', isEqualTo: false)
          .get();

      // Process each pending member
      for (var member in pendingMembers.docs) {
        final bankingName = member['bankingName'];
        if (bankingName == null || bankingName.isEmpty) continue;

        // Check if the message contains the member's banking name and is a credit transaction
        if (message.body!.toLowerCase().contains('credited') &&
            message.body!.toLowerCase().contains(bankingName.toLowerCase())) {
          // Mark the member as paid
          await member.reference.update({
            'payments.$selectedMonth': true,
            'forwarded': false,
          });
          _showSnackBar('Marked ${member['name']} as paid for $messageMonth');
          break;
        }
      }
    } catch (e) {
      print('Error processing single SMS: $e');
    }
  }

  // Add this method to print current month's messages
  Future<void> printCurrentMonthMessages() async {
    try {
      print('\n=== Starting SMS Debug ===');

      // Check if permission is granted
      final permissionStatus = await Permission.sms.status;
      print('Current SMS Permission Status: ${permissionStatus.toString()}');

      if (!permissionStatus.isGranted) {
        print('Requesting SMS Permission...');
        final result = await Permission.sms.request();
        print('Permission Request Result: ${result.toString()}');

        if (!result.isGranted) {
          print('Permission not granted. Cannot proceed.');
          _showSnackBar('SMS permission is required');
          return;
        }
      }

      setState(() {
        isLoading = true;
      });

      print('\nAttempting to read ALL SMS messages...');

      try {
        // First try to read any SMS message
        final allMessages = await _smsQuery.querySms(
          kinds: [SmsQueryKind.inbox],
          count: 10, // Just try to read 10 messages first
        );

        print('Successfully read ${allMessages.length} messages from inbox');
        if (allMessages.isNotEmpty) {
          print('\nFirst message details:');
          print('Address: ${allMessages[0].address}');
          print('Body: ${allMessages[0].body}');
        }

        // Now try to read all messages
        print('\nReading all SMS messages...');
        final messages = await _smsQuery.querySms(
          kinds: [SmsQueryKind.inbox],
        );
        print('Total SMS in inbox: ${messages.length}');

        // Print all unique sender addresses
        final senders = messages.map((m) => m.address).toSet();
        print('\nUnique sender addresses found:');
        senders.forEach((sender) => print(sender));

        // Filter SBIUPI messages
        final sbiMessages = messages.where((message) {
          final address = message.address ?? '';
          final isSbiUpi = address.endsWith('-SBIUPI');
          print('Checking address: $address, Is SBIUPI: $isSbiUpi');
          return isSbiUpi;
        }).toList();

        print('\n=== SBI UPI Messages ===');
        print('Total SBIUPI messages found: ${sbiMessages.length}');

        if (sbiMessages.isEmpty) {
          print('\nNo SBIUPI messages found. Showing sample of all messages:');
          for (var i = 0; i < 5 && i < messages.length; i++) {
            print('\nMessage ${i + 1}:');
            print('Sender: ${messages[i].address}');
            print('Body: ${messages[i].body}');
          }
          _showSnackBar(
              'No SBI UPI messages found. Check console for details.');
          return;
        }

        print('\nProcessing SBIUPI messages:');
        for (var message in sbiMessages) {
          print('\n-------------------');
          print('From: ${message.address}');
          print('Body: ${message.body}');
        }
      } catch (e, stack) {
        print('Error reading SMS messages: $e');
        print('Stack trace: $stack');
        _showSnackBar('Error reading SMS: $e');
      }

      print('\n=== End of SMS Debug ===');
    } catch (e, stack) {
      print('Top level error: $e');
      print('Stack trace: $stack');
      _showSnackBar('Error: $e');
    } finally {
      setState(() {
        isLoading = false;
      });
    }
  }

  @override
  Widget build(BuildContext context) {
    if (isInitializing) {
      return Scaffold(
        appBar: AppBar(
          title: Text('Members of ${widget.groupName}'),
          backgroundColor: Theme.of(context).colorScheme.primaryContainer,
          elevation: 0,
        ),
        body: const Center(
          child: CircularProgressIndicator(),
        ),
      );
    }

    return Scaffold(
      appBar: AppBar(
        title: Text('Members of ${widget.groupName}'),
        backgroundColor: Theme.of(context).colorScheme.primaryContainer,
        elevation: 0,
        actions: [
          // Add debug button to print messages
          IconButton(
            icon: const Icon(Icons.message),
            onPressed: printCurrentMonthMessages,
            tooltip: 'Print SMS Messages',
          ),
        ],
      ),
      body: Column(
        children: [
          Container(
            padding: const EdgeInsets.all(16),
            decoration: BoxDecoration(
              color: Theme.of(context)
                  .colorScheme
                  .primaryContainer
                  .withOpacity(0.3),
              borderRadius: const BorderRadius.only(
                bottomLeft: Radius.circular(24),
                bottomRight: Radius.circular(24),
              ),
            ),
            child: Column(
              crossAxisAlignment: CrossAxisAlignment.stretch,
              children: [
                // Month Filter Row
                Row(
                  children: [
                    Expanded(
                      child: Container(
                        padding: const EdgeInsets.symmetric(horizontal: 12),
                        decoration: BoxDecoration(
                          color: Theme.of(context).colorScheme.surface,
                          borderRadius: BorderRadius.circular(12),
                          border: Border.all(
                            color: Theme.of(context)
                                .colorScheme
                                .outline
                                .withOpacity(0.5),
                          ),
                        ),
                        child: DropdownButtonHideUnderline(
                          child: DropdownButton<String>(
                            hint: const Text('Select Month'),
                            value: selectedMonth,
                            isExpanded: true,
                            items: availableMonths.map((month) {
                              return DropdownMenuItem<String>(
                                value: month,
                                child: Text(month),
                              );
                            }).toList(),
                            onChanged: (newMonth) {
                              setState(() {
                                selectedMonth = newMonth;
                                _fetchPendingMembers();
                              });
                            },
                          ),
                        ),
                      ),
                    ),
                    const SizedBox(width: 8),
                    FilledButton.icon(
                      onPressed: _addNewMonth,
                      icon: const Icon(Icons.add),
                      label: const Text('New Month'),
                    ),
                  ],
                ),
                const SizedBox(height: 16),
                // Auto-mark payments button
                ElevatedButton.icon(
                  onPressed: isLoading ? null : processAutomaticPayments,
                  icon: isLoading
                      ? const SizedBox(
                          width: 20,
                          height: 20,
                          child: CircularProgressIndicator(strokeWidth: 2),
                        )
                      : const Icon(Icons.account_balance),
                  label: Text(
                    isLoading ? 'Processing...' : 'Auto-mark Payments from SMS',
                  ),
                  style: ElevatedButton.styleFrom(
                    padding: const EdgeInsets.symmetric(vertical: 12),
                    backgroundColor: Theme.of(context).colorScheme.secondary,
                    foregroundColor: Theme.of(context).colorScheme.onSecondary,
                  ),
                ),
                const SizedBox(height: 8),
                // Mention Button
                ElevatedButton.icon(
                  onPressed: isLoading ? null : _mentionPendingUsers,
                  icon: isLoading
                      ? const SizedBox(
                          width: 20,
                          height: 20,
                          child: CircularProgressIndicator(strokeWidth: 2),
                        )
                      : const Icon(Icons.notifications_active),
                  label: Text(
                    isLoading ? 'Mentioning Users...' : 'Mention Pending Users',
                  ),
                  style: ElevatedButton.styleFrom(
                    padding: const EdgeInsets.symmetric(vertical: 12),
                  ),
                ),
                const SizedBox(height: 8),
                ElevatedButton.icon(
                  onPressed: isLoading ? null : _mentionPaidUsers,
                  icon: isLoading
                      ? const SizedBox(
                          width: 20,
                          height: 20,
                          child: CircularProgressIndicator(strokeWidth: 2),
                        )
                      : const Icon(Icons.check_circle),
                  label: Text(
                    isLoading
                        ? 'Forwarding Paid Members...'
                        : 'Forward Paid Members',
                  ),
                  style: ElevatedButton.styleFrom(
                    padding: const EdgeInsets.symmetric(vertical: 12),
                    backgroundColor:
                        Theme.of(context).colorScheme.primaryContainer,
                  ),
                ),
              ],
            ),
          ),
          // Members List
          Expanded(
            child: _buildMembersListView(),
          ),
        ],
      ),
      floatingActionButton: FloatingActionButton.extended(
        onPressed: () => _showAddMemberDialog(),
        icon: const Icon(Icons.person_add),
        label: const Text('Add Member'),
      ),
    );
  }

  // Member list UI
  Widget _buildMemberList(
    BuildContext context,
    String title,
    List<DocumentSnapshot> members,
  ) {
    return Padding(
      padding: const EdgeInsets.all(8.0),
      child: Column(
        crossAxisAlignment: CrossAxisAlignment.start,
        children: [
          Text(
            title,
            style: const TextStyle(fontSize: 18, fontWeight: FontWeight.bold),
          ),
          const SizedBox(height: 8),
          ListView.builder(
            shrinkWrap: true,
            physics: const NeverScrollableScrollPhysics(),
            itemCount: members.length,
            itemBuilder: (context, index) {
              final member = members[index];
              return ListTile(
                title: Text(member['name']),
                subtitle: Text('Phone: ${member['phoneNumber']}'),
                trailing: PopupMenuButton<String>(
                  onSelected: (value) {
                    if (value == 'Edit') {
                      _showEditMemberDialog(member);
                    } else if (value == 'Delete') {
                      _deleteMember(member);
                    }
                  },
                  itemBuilder: (context) => [
                    const PopupMenuItem(
                      value: 'Edit',
                      child: Text('Edit'),
                    ),
                    const PopupMenuItem(
                      value: 'Delete',
                      child: Text('Delete'),
                    ),
                  ],
                ),
                leading: IconButton(
                  icon: Icon(
                    (member['payments'][selectedMonth] ?? false)
                        ? Icons.check_circle
                        : Icons.check_circle_outline,
                    color: (member['payments'][selectedMonth] ?? false)
                        ? Colors.green
                        : Colors.grey,
                  ),
                  onPressed: () {
                    membersCollection.doc(member.id).update({
                      'payments.$selectedMonth':
                          !(member['payments'][selectedMonth] ?? false),
                    });
                  },
                ),
              );
            },
          ),
        ],
      ),
    );
  }

  // Edit Member Dialog
  void _showEditMemberDialog(DocumentSnapshot member) {
    final TextEditingController nameController =
        TextEditingController(text: member['name']);
    final TextEditingController phoneController =
        TextEditingController(text: member['phoneNumber']);
    final TextEditingController groupIdController =
        TextEditingController(text: member['groupId'] ?? '');
    final TextEditingController bankingNameController =
        TextEditingController(text: member['bankingName'] ?? '');
    final TextEditingController amountController =
        TextEditingController(text: member['paymentAmount']?.toString() ?? '');

    showDialog(
      context: context,
      builder: (context) => AlertDialog(
        title: const Text('Edit Member'),
        content: Column(
          mainAxisSize: MainAxisSize.min,
          children: [
            TextField(
              controller: nameController,
              decoration: const InputDecoration(hintText: 'Name'),
            ),
            const SizedBox(height: 8),
            TextField(
              controller: phoneController,
              decoration: const InputDecoration(hintText: 'Phone Number'),
              keyboardType: TextInputType.phone,
            ),
            const SizedBox(height: 8),
            TextField(
              controller: groupIdController,
              decoration: const InputDecoration(hintText: 'Group ID'),
            ),
            const SizedBox(height: 8),
            TextField(
              controller: bankingNameController,
              decoration: const InputDecoration(
                hintText: 'Banking Name (Optional)',
                helperText: 'Name as it appears in bank transactions',
              ),
            ),
            const SizedBox(height: 8),
            TextField(
              controller: amountController,
              decoration: const InputDecoration(
                hintText: 'Payment Amount',
                helperText: 'Monthly payment amount to check in transactions',
              ),
              keyboardType: TextInputType.number,
            ),
          ],
        ),
        actions: [
          TextButton(
            onPressed: () {
              Navigator.pop(context);
            },
            child: const Text('Cancel'),
          ),
          TextButton(
            onPressed: () {
              final name = nameController.text.trim();
              final phone = phoneController.text.trim();
              final groupId = groupIdController.text.trim();
              final bankingName = bankingNameController.text.trim();
              final amountText = amountController.text.trim();

              if (name.isNotEmpty && phone.isNotEmpty && groupId.isNotEmpty) {
                // Parse amount if provided
                double? amount;
                if (amountText.isNotEmpty) {
                  amount = double.tryParse(amountText);
                  if (amount == null) {
                    ScaffoldMessenger.of(context).showSnackBar(
                      const SnackBar(content: Text('Invalid payment amount')),
                    );
                    return;
                  }
                }

                member.reference.update({
                  'name': name,
                  'phoneNumber': phone,
                  'groupId': groupId,
                  'bankingName': bankingName.isNotEmpty ? bankingName : null,
                  'paymentAmount': amount,
                });

                Navigator.pop(context);
                ScaffoldMessenger.of(context).showSnackBar(
                  const SnackBar(content: Text('Member updated successfully')),
                );
              } else {
                ScaffoldMessenger.of(context).showSnackBar(
                  const SnackBar(
                      content: Text('Required fields cannot be empty!')),
                );
              }
            },
            child: const Text('Save'),
          ),
        ],
      ),
    );
  }

  // Delete Member
  void _deleteMember(DocumentSnapshot member) {
    showDialog(
      context: context,
      builder: (context) => AlertDialog(
        title: const Text('Delete Member'),
        content: const Text('Are you sure you want to delete this member?'),
        actions: [
          TextButton(
            onPressed: () {
              Navigator.pop(context);
            },
            child: const Text('Cancel'),
          ),
          TextButton(
            onPressed: () async {
              await member.reference.delete();
              Navigator.pop(context);
              ScaffoldMessenger.of(context).showSnackBar(
                const SnackBar(content: Text('Member deleted successfully')),
              );
            },
            child: const Text('Delete'),
          ),
        ],
      ),
    );
  }

  // Add Member Dialog
  void _showAddMemberDialog() {
    final TextEditingController nameController = TextEditingController();
    final TextEditingController phoneController = TextEditingController();
    final TextEditingController groupIdController = TextEditingController();
    final TextEditingController bankingNameController = TextEditingController();
    final TextEditingController amountController = TextEditingController();

    showDialog(
      context: context,
      builder: (context) => AlertDialog(
        title: const Text('Add New Member'),
        content: Column(
          mainAxisSize: MainAxisSize.min,
          children: [
            TextField(
              controller: nameController,
              decoration: const InputDecoration(hintText: 'Name'),
            ),
            const SizedBox(height: 8),
            TextField(
              controller: phoneController,
              decoration: const InputDecoration(hintText: 'Phone Number'),
              keyboardType: TextInputType.phone,
            ),
            const SizedBox(height: 8),
            TextField(
              controller: groupIdController,
              decoration: const InputDecoration(hintText: 'Group ID'),
            ),
            const SizedBox(height: 8),
            TextField(
              controller: bankingNameController,
              decoration: const InputDecoration(
                hintText: 'Banking Name (Optional)',
                helperText: 'Name as it appears in bank transactions',
              ),
            ),
            const SizedBox(height: 8),
            TextField(
              controller: amountController,
              decoration: const InputDecoration(
                hintText: 'Payment Amount',
                helperText: 'Monthly payment amount to check in transactions',
              ),
              keyboardType: TextInputType.number,
            ),
          ],
        ),
        actions: [
          TextButton(
            onPressed: () {
              Navigator.pop(context);
            },
            child: const Text('Cancel'),
          ),
          TextButton(
            onPressed: () async {
              final name = nameController.text.trim();
              final phone = phoneController.text.trim();
              final groupId = groupIdController.text.trim();
              final bankingName = bankingNameController.text.trim();
              final amountText = amountController.text.trim();

              if (name.isNotEmpty && phone.isNotEmpty && groupId.isNotEmpty) {
                // Parse amount if provided
                double? amount;
                if (amountText.isNotEmpty) {
                  amount = double.tryParse(amountText);
                  if (amount == null) {
                    ScaffoldMessenger.of(context).showSnackBar(
                      const SnackBar(content: Text('Invalid payment amount')),
                    );
                    return;
                  }
                }

                // Initialize the payments field with all existing months set to false
                final Map<String, bool> initialPayments = {
                  for (var month in availableMonths) month: false,
                };

                // Add the new member to Firestore
                await membersCollection.add({
                  'name': name,
                  'phoneNumber': phone,
                  'groupId': groupId,
                  'bankingName': bankingName.isNotEmpty ? bankingName : null,
                  'paymentAmount': amount,
                  'payments': initialPayments,
                  'forwarded': false,
                });

                Navigator.pop(context);
                ScaffoldMessenger.of(context).showSnackBar(
                  const SnackBar(content: Text('Member added successfully')),
                );
              } else {
                ScaffoldMessenger.of(context).showSnackBar(
                  const SnackBar(
                      content: Text('Required fields cannot be empty!')),
                );
              }
            },
            child: const Text('Add'),
          ),
        ],
      ),
    );
  }

  Widget _buildMembersListView() {
    return StreamBuilder<QuerySnapshot>(
      stream: membersCollection.snapshots(),
      builder: (context, snapshot) {
        if (snapshot.connectionState == ConnectionState.waiting) {
          return const Center(
            child: CircularProgressIndicator(),
          );
        }

        if (!snapshot.hasData || snapshot.data!.docs.isEmpty) {
          return Center(
            child: Column(
              mainAxisAlignment: MainAxisAlignment.center,
              children: [
                Icon(
                  Icons.people_outline,
                  size: 64,
                  color: Theme.of(context).colorScheme.secondary,
                ),
                const SizedBox(height: 16),
                const Text(
                  'No Members Found',
                  style: TextStyle(fontSize: 18),
                ),
              ],
            ),
          );
        }

        final members = snapshot.data!.docs;
        final filteredMembers = members.where((member) {
          final payments = member['payments'] ?? {};
          return selectedMonth == null || payments[selectedMonth] != null;
        }).toList();

        final paidMembers = filteredMembers
            .where((member) => member['payments'][selectedMonth] ?? false)
            .toList();
        final pendingMembers = filteredMembers
            .where((member) => !(member['payments'][selectedMonth] ?? false))
            .toList();

        return ListView(
          padding: const EdgeInsets.all(16),
          children: [
            _buildMemberSection(
              context,
              'Paid Members',
              paidMembers,
              Icons.check_circle,
              Colors.green,
            ),
            const SizedBox(height: 24),
            _buildMemberSection(
              context,
              'Pending Members',
              pendingMembers,
              Icons.pending,
              Colors.orange,
            ),
          ],
        );
      },
    );
  }

  Widget _buildMemberSection(
    BuildContext context,
    String title,
    List<DocumentSnapshot> members,
    IconData icon,
    Color iconColor,
  ) {
    return Column(
      crossAxisAlignment: CrossAxisAlignment.start,
      children: [
        Row(
          children: [
            Icon(icon, color: iconColor),
            const SizedBox(width: 8),
            Text(
              '$title (${members.length})',
              style: Theme.of(context).textTheme.titleLarge?.copyWith(
                    fontWeight: FontWeight.bold,
                  ),
            ),
          ],
        ),
        const SizedBox(height: 8),
        if (members.isEmpty)
          Padding(
            padding: const EdgeInsets.all(16),
            child: Text(
              'No ${title.toLowerCase()} yet',
              style: TextStyle(
                color: Theme.of(context).colorScheme.outline,
              ),
            ),
          )
        else
          ListView.builder(
            shrinkWrap: true,
            physics: const NeverScrollableScrollPhysics(),
            itemCount: members.length,
            itemBuilder: (context, index) {
              final member = members[index];
              return Card(
                margin: const EdgeInsets.symmetric(vertical: 4),
                child: ListTile(
                  contentPadding: const EdgeInsets.symmetric(
                    horizontal: 16,
                    vertical: 8,
                  ),
                  leading: CircleAvatar(
                    backgroundColor:
                        Theme.of(context).colorScheme.primaryContainer,
                    child: Text(
                      member['name'][0].toUpperCase(),
                      style: TextStyle(
                        color: Theme.of(context).colorScheme.onPrimaryContainer,
                      ),
                    ),
                  ),
                  title: Text(
                    member['name'],
                    style: const TextStyle(fontWeight: FontWeight.bold),
                  ),
                  subtitle: Text(member['phoneNumber']),
                  trailing: Row(
                    mainAxisSize: MainAxisSize.min,
                    children: [
                      IconButton(
                        icon: Icon(
                          member['payments'][selectedMonth] ?? false
                              ? Icons.check_circle
                              : Icons.check_circle_outline,
                          color: member['payments'][selectedMonth] ?? false
                              ? Colors.green
                              : Colors.grey,
                        ),
                        onPressed: () => _togglePaymentStatus(member),
                      ),
                      PopupMenuButton<String>(
                        icon: const Icon(Icons.more_vert),
                        onSelected: (value) =>
                            _handleMemberAction(value, member),
                        itemBuilder: (context) => [
                          const PopupMenuItem(
                            value: 'edit',
                            child: Row(
                              children: [
                                Icon(Icons.edit, size: 20),
                                SizedBox(width: 8),
                                Text('Edit'),
                              ],
                            ),
                          ),
                          const PopupMenuItem(
                            value: 'delete',
                            child: Row(
                              children: [
                                Icon(Icons.delete, size: 20, color: Colors.red),
                                SizedBox(width: 8),
                                Text('Delete',
                                    style: TextStyle(color: Colors.red)),
                              ],
                            ),
                          ),
                        ],
                      ),
                    ],
                  ),
                ),
              );
            },
          ),
      ],
    );
  }

  void _togglePaymentStatus(DocumentSnapshot member) {
    final bool currentStatus = member['payments'][selectedMonth] ?? false;
    final bool newStatus = !currentStatus;

    membersCollection.doc(member.id).update({
      'payments.$selectedMonth': newStatus,
      // Reset forwarded status when marking as paid
      if (newStatus) 'forwarded': false,
    }).then((_) {
      // Fetch pending members after payment status is updated
      _fetchPendingMembers();
    });
  }

  void _handleMemberAction(String action, DocumentSnapshot member) {
    switch (action) {
      case 'edit':
        _showEditMemberDialog(member);
        break;
      case 'delete':
        _deleteMember(member);
        break;
    }
  }
}
