import 'package:flutter/material.dart';
import 'dart:convert';
// import 'dart:math';
import 'package:http/http.dart' as http;
import 'package:firebase_core/firebase_core.dart';
import 'package:cloud_firestore/cloud_firestore.dart';
import 'package:flutter_sms_inbox/flutter_sms_inbox.dart';
import 'package:permission_handler/permission_handler.dart';
import 'firebase_options.dart'; // Generated by FlutterFire CLI
import 'dart:async';

void main() async {
  WidgetsFlutterBinding.ensureInitialized();
  await Firebase.initializeApp(
    options: DefaultFirebaseOptions.currentPlatform,
  );
  runApp(const MyApp());
}

class MyApp extends StatelessWidget {
  const MyApp({super.key});

  @override
  Widget build(BuildContext context) {
    return MaterialApp(
      debugShowCheckedModeBanner: false,
      theme: ThemeData(
        colorScheme: ColorScheme.fromSeed(
          //seedColor: const Color(0xFF1DB954), // Spotify Green
          seedColor: Colors.blue,
          brightness: Brightness.light,
        ),
        useMaterial3: true,
        cardTheme: const CardTheme(
          elevation: 2,
          margin: EdgeInsets.symmetric(horizontal: 16, vertical: 8),
        ),
      ),
      home: const BotStatusWrapper(child: SmsPermissionWrapper()),
    );
  }
}

class BotStatusWrapper extends StatefulWidget {
  final Widget child;

  const BotStatusWrapper({super.key, required this.child});

  @override
  State<BotStatusWrapper> createState() => _BotStatusWrapperState();
}

class _BotStatusWrapperState extends State<BotStatusWrapper> {
  Timer? _statusCheckTimer;
  String _botStatus = 'offline';
  bool _isInitialized = false;
  bool _isFirstCheck = true;
  double _uptime = 0;

  @override
  void initState() {
    super.initState();
    _showInitialDialog();
  }

  @override
  void dispose() {
    _statusCheckTimer?.cancel();
    super.dispose();
  }

  void _showInitialDialog() {
    Future.delayed(Duration.zero, () {
      showDialog(
        context: context,
        barrierDismissible: false,
        builder: (context) => AlertDialog(
          title: Row(
            children: [
              Icon(
                Icons.smart_toy,
                color: Theme.of(context).colorScheme.primary,
              ),
              const SizedBox(width: 8),
              const Text('Start WhatsApp Bot?'),
            ],
          ),
          content: const Text(
            'Would you like to start the WhatsApp bot? This will help with sending reminders and payment updates.',
          ),
          actions: [
            TextButton(
              onPressed: () {
                Navigator.pop(context);
              },
              child: const Text('Skip'),
            ),
            FilledButton(
              onPressed: () {
                Navigator.pop(context);
                _startBotStatusCheck();
              },
              child: const Text('Start Bot'),
            ),
          ],
        ),
      );
    });
  }

  Future<void> _checkBotStatus() async {
    try {
      final url = Uri.parse("https://nodejs-test-hosting.onrender.com/");
      final response = await http.get(url);

      if (response.statusCode == 200) {
        final data = jsonDecode(response.body);
        setState(() {
          _botStatus = data['status'] ?? 'offline';
          _isInitialized = data['initialized'] ?? false;
          _uptime = (data['uptime'] ?? 0).toDouble();

          // If bot is running and initialized, stop the timer
          if (_botStatus == 'running' && _isInitialized) {
            _statusCheckTimer?.cancel();
          }
        });
      }
    } catch (e) {
      setState(() {
        _botStatus = 'error';
      });
    }
  }

  void _startBotStatusCheck() {
    // Show initial loading dialog for first check
    if (_isFirstCheck) {
      showDialog(
        context: context,
        barrierDismissible: false,
        builder: (context) => const Center(
          child: Card(
            child: Padding(
              padding: EdgeInsets.all(16.0),
              child: Column(
                mainAxisSize: MainAxisSize.min,
                children: [
                  CircularProgressIndicator(),
                  SizedBox(height: 16),
                  Text('Starting WhatsApp Bot...'),
                  SizedBox(height: 8),
                  Text(
                    'This might take a few minutes',
                    style: TextStyle(fontSize: 12),
                  ),
                ],
              ),
            ),
          ),
        ),
      );
    }

    // Make initial check
    _checkBotStatus().then((_) {
      if (_isFirstCheck) {
        Navigator.of(context).pop(); // Dismiss loading dialog
        _isFirstCheck = false;
      }
    });

    // Start periodic checks
    _statusCheckTimer?.cancel();
    _statusCheckTimer = Timer.periodic(const Duration(seconds: 10), (timer) {
      _checkBotStatus();
    });
  }

  @override
  Widget build(BuildContext context) {
    return Scaffold(
      body: widget.child,
      floatingActionButtonLocation: FloatingActionButtonLocation.centerDocked,
      bottomNavigationBar: BottomAppBar(
        height: 80,
        padding: const EdgeInsets.all(16),
        child: Row(
          mainAxisAlignment: MainAxisAlignment.center,
          children: [
            _BotStatusButton(
              status: _botStatus,
              isInitialized: _isInitialized,
              uptime: _uptime,
              onRefresh: _startBotStatusCheck,
            ),
          ],
        ),
      ),
    );
  }
}

class _BotStatusButton extends StatelessWidget {
  final String status;
  final bool isInitialized;
  final double uptime;
  final VoidCallback onRefresh;

  const _BotStatusButton({
    required this.status,
    required this.isInitialized,
    required this.uptime,
    required this.onRefresh,
  });

  String _formatUptime(double seconds) {
    if (seconds < 60) {
      return '${seconds.toStringAsFixed(0)} seconds';
    } else if (seconds < 3600) {
      final minutes = (seconds / 60).floor();
      return '$minutes minutes';
    } else if (seconds < 86400) {
      final hours = (seconds / 3600).floor();
      final minutes = ((seconds % 3600) / 60).floor();
      return '$hours hours ${minutes > 0 ? '$minutes min' : ''}';
    } else {
      final days = (seconds / 86400).floor();
      final hours = ((seconds % 86400) / 3600).floor();
      return '$days days ${hours > 0 ? '$hours hrs' : ''}';
    }
  }

  void _showBotDetails(BuildContext context) {
    showModalBottomSheet(
      context: context,
      builder: (context) => SafeArea(
        child: Column(
          mainAxisSize: MainAxisSize.min,
          children: [
            Container(
              width: 120,
              height: 120,
              margin: const EdgeInsets.all(24),
              decoration: BoxDecoration(
                color: getStatusColor(status, isInitialized).withOpacity(0.1),
                shape: BoxShape.circle,
              ),
              child: Center(
                child: Icon(
                  getStatusIcon(status, isInitialized),
                  size: 48,
                  color: getStatusColor(status, isInitialized),
                ),
              ),
            ),
            Text(
              getStatusText(status, isInitialized),
              style: Theme.of(context).textTheme.titleLarge?.copyWith(
                    color: getStatusColor(status, isInitialized),
                    fontWeight: FontWeight.w600,
                  ),
            ),
            const SizedBox(height: 24),
            _buildDetailRow(
              context,
              'Status',
              status,
              Icons.info,
            ),
            _buildDetailRow(
              context,
              'WhatsApp Client',
              isInitialized ? 'Initialized' : 'Not Initialized',
              Icons.chat,
            ),
            _buildDetailRow(
              context,
              'Uptime',
              _formatUptime(uptime),
              Icons.timer,
            ),
            const SizedBox(height: 24),
            Row(
              mainAxisAlignment: MainAxisAlignment.center,
              children: [
                FilledButton.icon(
                  onPressed: () {
                    Navigator.pop(context);
                    onRefresh();
                  },
                  icon: const Icon(Icons.refresh),
                  label: const Text('Refresh Status'),
                ),
                const SizedBox(width: 16),
                OutlinedButton.icon(
                  onPressed: () {
                    showDialog(
                      context: context,
                      builder: (context) => AlertDialog(
                        title: Row(
                          children: [
                            Icon(
                              Icons.warning,
                              color: Theme.of(context).colorScheme.error,
                            ),
                            const SizedBox(width: 8),
                            const Text('Reinitialize Bot?'),
                          ],
                        ),
                        content: const Text(
                          'This will restart the WhatsApp client. The bot will be temporarily unavailable during reinitialization.',
                        ),
                        actions: [
                          TextButton(
                            onPressed: () => Navigator.pop(context),
                            child: const Text('Cancel'),
                          ),
                          FilledButton(
                            onPressed: () async {
                              Navigator.pop(
                                  context); // Close confirmation dialog
                              Navigator.pop(context); // Close bot details

                              // Show loading dialog
                              showDialog(
                                context: context,
                                barrierDismissible: false,
                                builder: (context) => const Center(
                                  child: Card(
                                    child: Padding(
                                      padding: EdgeInsets.all(16.0),
                                      child: Column(
                                        mainAxisSize: MainAxisSize.min,
                                        children: [
                                          CircularProgressIndicator(),
                                          SizedBox(height: 16),
                                          Text(
                                              'Reinitializing WhatsApp Bot...'),
                                          SizedBox(height: 8),
                                          Text(
                                            'This may take a few minutes',
                                            style: TextStyle(fontSize: 12),
                                          ),
                                        ],
                                      ),
                                    ),
                                  ),
                                ),
                              );

                              try {
                                final url = Uri.parse(
                                    "https://nodejs-test-hosting.onrender.com/reinitialize");
                                final response = await http.post(url);
                                final data = jsonDecode(response.body);

                                Navigator.pop(context); // Close loading dialog

                                ScaffoldMessenger.of(context).showSnackBar(
                                  SnackBar(
                                    content: Text(data['message']),
                                    backgroundColor: data['success']
                                        ? Colors.green
                                        : Colors.red,
                                  ),
                                );

                                if (data['success']) {
                                  onRefresh(); // Refresh status after successful reinitialization
                                }
                              } catch (e) {
                                Navigator.pop(context); // Close loading dialog
                                ScaffoldMessenger.of(context).showSnackBar(
                                  SnackBar(
                                    content: Text('Error: $e'),
                                    backgroundColor: Colors.red,
                                  ),
                                );
                              }
                            },
                            style: FilledButton.styleFrom(
                              backgroundColor:
                                  Theme.of(context).colorScheme.error,
                            ),
                            child: const Text('Reinitialize'),
                          ),
                        ],
                      ),
                    );
                  },
                  icon: const Icon(Icons.restart_alt),
                  label: const Text('Reinitialize Bot'),
                ),
              ],
            ),
            const SizedBox(height: 24),
          ],
        ),
      ),
    );
  }

  Widget _buildDetailRow(
    BuildContext context,
    String label,
    String value,
    IconData icon,
  ) {
    return Padding(
      padding: const EdgeInsets.symmetric(horizontal: 24, vertical: 8),
      child: Row(
        children: [
          Icon(
            icon,
            size: 20,
            color: Theme.of(context).colorScheme.outline,
          ),
          const SizedBox(width: 12),
          Text(
            label,
            style: Theme.of(context).textTheme.bodyLarge?.copyWith(
                  color: Theme.of(context).colorScheme.outline,
                ),
          ),
          const Spacer(),
          Container(
            padding: const EdgeInsets.symmetric(horizontal: 12, vertical: 4),
            decoration: BoxDecoration(
              color: Theme.of(context).colorScheme.surfaceVariant,
              borderRadius: BorderRadius.circular(12),
            ),
            child: Text(
              value,
              style: Theme.of(context).textTheme.bodyMedium?.copyWith(
                    color: Theme.of(context).colorScheme.onSurfaceVariant,
                    fontWeight: FontWeight.w500,
                  ),
            ),
          ),
        ],
      ),
    );
  }

  Color getStatusColor(String status, bool isInitialized) {
    final isOffline = status == 'offline';
    final isError = status == 'error';
    final isInitializing = status == 'initializing';
    final isRunning = status == 'running';

    if (isError) return Colors.red;
    if (isOffline) return Colors.grey;
    if (isInitializing) return Colors.orange;
    if (isRunning && !isInitialized) return Colors.blue;
    return Colors.green;
  }

  String getStatusText(String status, bool isInitialized) {
    final isOffline = status == 'offline';
    final isError = status == 'error';
    final isInitializing = status == 'initializing';
    final isRunning = status == 'running';

    if (isError) return 'Bot Error';
    if (isOffline) return 'Bot Offline';
    if (isInitializing) return 'Bot Starting';
    if (isRunning && !isInitialized) return 'Client Loading';
    return 'Bot Active';
  }

  IconData getStatusIcon(String status, bool isInitialized) {
    final isOffline = status == 'offline';
    final isError = status == 'error';
    final isInitializing = status == 'initializing';
    final isRunning = status == 'running';

    if (isError) return Icons.error;
    if (isOffline) return Icons.power_off;
    if (isInitializing) return Icons.rocket_launch;
    if (isRunning && !isInitialized) return Icons.downloading;
    return Icons.check_circle;
  }

  @override
  Widget build(BuildContext context) {
    return Material(
      color: getStatusColor(status, isInitialized).withOpacity(0.1),
      borderRadius: BorderRadius.circular(24),
      child: InkWell(
        onTap: () => _showBotDetails(context),
        borderRadius: BorderRadius.circular(24),
        child: Container(
          padding: const EdgeInsets.symmetric(horizontal: 16, vertical: 8),
          child: Row(
            mainAxisSize: MainAxisSize.min,
            children: [
              // Animated Icon
              TweenAnimationBuilder<double>(
                tween: Tween(begin: 0.0, end: 1.0),
                duration: const Duration(seconds: 1),
                builder: (context, value, child) {
                  return Transform.rotate(
                    angle: status == 'initializing' ||
                            (status == 'running' && !isInitialized)
                        ? value * 2 * 3.14159
                        : 0,
                    child: Icon(
                      getStatusIcon(status, isInitialized),
                      color: getStatusColor(status, isInitialized),
                    ),
                  );
                },
              ),
              const SizedBox(width: 8),
              // Status Text with Dot Animation
              Row(
                children: [
                  Text(
                    getStatusText(status, isInitialized),
                    style: TextStyle(
                      color: getStatusColor(status, isInitialized),
                      fontWeight: FontWeight.w600,
                    ),
                  ),
                  if (status == 'initializing' ||
                      (status == 'running' && !isInitialized)) ...[
                    const SizedBox(width: 4),
                    _LoadingDots(color: getStatusColor(status, isInitialized)),
                  ],
                ],
              ),
            ],
          ),
        ),
      ),
    );
  }
}

class _LoadingDots extends StatefulWidget {
  final Color color;

  const _LoadingDots({required this.color});

  @override
  State<_LoadingDots> createState() => _LoadingDotsState();
}

class _LoadingDotsState extends State<_LoadingDots>
    with SingleTickerProviderStateMixin {
  late AnimationController _controller;
  late List<Animation<double>> _animations;

  @override
  void initState() {
    super.initState();
    _controller = AnimationController(
      vsync: this,
      duration: const Duration(milliseconds: 1000),
    )..repeat();

    _animations = List.generate(3, (index) {
      return Tween<double>(begin: 0, end: 1).animate(
        CurvedAnimation(
          parent: _controller,
          curve:
              Interval(index * 0.2, 0.6 + index * 0.2, curve: Curves.easeInOut),
        ),
      );
    });
  }

  @override
  void dispose() {
    _controller.dispose();
    super.dispose();
  }

  @override
  Widget build(BuildContext context) {
    return Row(
      mainAxisSize: MainAxisSize.min,
      children: _animations.map((animation) {
        return AnimatedBuilder(
          animation: animation,
          builder: (context, child) {
            return Container(
              width: 4,
              height: 4,
              margin: const EdgeInsets.symmetric(horizontal: 1),
              decoration: BoxDecoration(
                color: widget.color.withOpacity(animation.value),
                shape: BoxShape.circle,
              ),
            );
          },
        );
      }).toList(),
    );
  }
}

class SmsPermissionWrapper extends StatefulWidget {
  const SmsPermissionWrapper({super.key});

  @override
  State<SmsPermissionWrapper> createState() => _SmsPermissionWrapperState();
}

class _SmsPermissionWrapperState extends State<SmsPermissionWrapper> {
  bool _permissionChecked = false;
  bool _hasPermission = false;

  @override
  void initState() {
    super.initState();
    _checkPermission();
  }

  Future<void> _checkPermission() async {
    final status = await Permission.sms.status;
    setState(() {
      _hasPermission = status.isGranted;
      _permissionChecked = true;
    });

    if (!_hasPermission) {
      _showPermissionDialog();
    }
  }

  Future<void> _requestPermission() async {
    final status = await Permission.sms.request();
    setState(() {
      _hasPermission = status.isGranted;
    });
  }

  void _showPermissionDialog() {
    showDialog(
      context: context,
      barrierDismissible: false,
      builder: (context) => AlertDialog(
        title: const Text('SMS Permission Required'),
        content: const Text(
          'This app needs SMS permission to automatically mark payments based on bank transaction messages. Without this permission, you\'ll need to mark payments manually.',
        ),
        actions: [
          TextButton(
            onPressed: () {
              Navigator.pop(context);
            },
            child: const Text('Skip'),
          ),
          FilledButton(
            onPressed: () async {
              Navigator.pop(context);
              await _requestPermission();
            },
            child: const Text('Grant Permission'),
          ),
        ],
      ),
    );
  }

  @override
  Widget build(BuildContext context) {
    if (!_permissionChecked) {
      return const Scaffold(
        body: Center(
          child: CircularProgressIndicator(),
        ),
      );
    }

    return GroupListScreen();
  }
}

// Main screen to display and manage groups
class GroupListScreen extends StatelessWidget {
  final CollectionReference groupsCollection =
      FirebaseFirestore.instance.collection('groups1');

  GroupListScreen({super.key});

  @override
  Widget build(BuildContext context) {
    print('\n=== Building GroupListScreen ===');
    return Scaffold(
      appBar: AppBar(
        title: Row(
          children: [
            Icon(
              Icons.library_music,
              color: Theme.of(context).colorScheme.onPrimaryContainer,
            ),
            const SizedBox(width: 12),
            const Text('Spotify Family Plans'),
          ],
        ),
        actions: [
          IconButton(
            icon: const Icon(Icons.refresh),
            tooltip: 'Refresh Everything',
            onPressed: () {
              print('Refreshing app state...');
              // Show loading indicator
              showDialog(
                context: context,
                barrierDismissible: false,
                builder: (context) => const Center(
                  child: Card(
                    child: Padding(
                      padding: EdgeInsets.all(16.0),
                      child: Column(
                        mainAxisSize: MainAxisSize.min,
                        children: [
                          CircularProgressIndicator(),
                          SizedBox(height: 16),
                          Text('Refreshing...'),
                        ],
                      ),
                    ),
                  ),
                ),
              );

              // Simulate refresh
              Future.delayed(const Duration(seconds: 1), () {
                Navigator.pushReplacement(
                  context,
                  MaterialPageRoute(builder: (context) => GroupListScreen()),
                );
              });
            },
          ),
        ],
        elevation: 0,
        backgroundColor: Theme.of(context).colorScheme.primaryContainer,
      ),
      body: StreamBuilder<QuerySnapshot>(
        stream: groupsCollection.snapshots(),
        builder: (context, snapshot) {
          if (snapshot.connectionState == ConnectionState.waiting) {
            print('Loading groups...');
            return Center(
              child: Column(
                mainAxisAlignment: MainAxisAlignment.center,
                children: [
                  const CircularProgressIndicator(),
                  const SizedBox(height: 16),
                  Text(
                    'Loading your plans...',
                    style: Theme.of(context).textTheme.titleMedium,
                  ),
                ],
              ),
            );
          }

          if (!snapshot.hasData || snapshot.data!.docs.isEmpty) {
            print('No groups found');
            return Center(
              child: Column(
                mainAxisAlignment: MainAxisAlignment.center,
                children: [
                  Icon(
                    Icons.queue_music,
                    size: 64,
                    color: Theme.of(context).colorScheme.secondary,
                  ),
                  const SizedBox(height: 16),
                  Text(
                    'No Family Plans Yet',
                    style: Theme.of(context).textTheme.titleLarge,
                  ),
                  const SizedBox(height: 8),
                  Text(
                    'Create a new plan to start tracking payments',
                    style: Theme.of(context).textTheme.bodyMedium?.copyWith(
                          color: Theme.of(context).colorScheme.outline,
                        ),
                  ),
                ],
              ),
            );
          }

          print('Found ${snapshot.data!.docs.length} groups');
          final groups = snapshot.data!.docs;
          return ListView.builder(
            padding: const EdgeInsets.all(16),
            itemCount: groups.length,
            itemBuilder: (context, index) {
              final group = groups[index];
              print('Building group card: ${group['groupName']}');

              return Padding(
                padding: const EdgeInsets.symmetric(vertical: 4),
                child: Material(
                  borderRadius: BorderRadius.circular(12),
                  color: Theme.of(context).colorScheme.surface,
                  child: InkWell(
                    borderRadius: BorderRadius.circular(12),
                    onTap: () => _navigateToGroupDetails(context, group),
                    child: Padding(
                      padding: const EdgeInsets.all(16),
                      child: Row(
                        children: [
                          Container(
                            width: 48,
                            height: 48,
                            decoration: BoxDecoration(
                              color: Theme.of(context)
                                  .colorScheme
                                  .primaryContainer,
                              shape: BoxShape.circle,
                            ),
                            child: Center(
                              child: Icon(
                                Icons.album,
                                color: Theme.of(context)
                                    .colorScheme
                                    .onPrimaryContainer,
                              ),
                            ),
                          ),
                          const SizedBox(width: 16),
                          Expanded(
                            child: Column(
                              crossAxisAlignment: CrossAxisAlignment.start,
                              children: [
                                Text(
                                  group['groupName'],
                                  style: const TextStyle(
                                    fontSize: 16,
                                    fontWeight: FontWeight.w600,
                                  ),
                                ),
                                const SizedBox(height: 4),
                                Text(
                                  'Tap to manage members',
                                  style: Theme.of(context)
                                      .textTheme
                                      .bodySmall
                                      ?.copyWith(
                                        color: Theme.of(context)
                                            .colorScheme
                                            .outline,
                                      ),
                                ),
                              ],
                            ),
                          ),
                          IconButton(
                            icon: Icon(
                              Icons.more_vert,
                              color: Theme.of(context).colorScheme.outline,
                            ),
                            onPressed: () {
                              showModalBottomSheet(
                                context: context,
                                builder: (context) => SafeArea(
                                  child: Column(
                                    mainAxisSize: MainAxisSize.min,
                                    children: [
                                      Padding(
                                        padding: const EdgeInsets.all(16),
                                        child: Row(
                                          children: [
                                            Container(
                                              width: 40,
                                              height: 40,
                                              decoration: BoxDecoration(
                                                color: Theme.of(context)
                                                    .colorScheme
                                                    .primaryContainer,
                                                shape: BoxShape.circle,
                                              ),
                                              child: Center(
                                                child: Icon(
                                                  Icons.album,
                                                  color: Theme.of(context)
                                                      .colorScheme
                                                      .onPrimaryContainer,
                                                ),
                                              ),
                                            ),
                                            const SizedBox(width: 12),
                                            Expanded(
                                              child: Column(
                                                crossAxisAlignment:
                                                    CrossAxisAlignment.start,
                                                children: [
                                                  Text(
                                                    group['groupName'],
                                                    style: const TextStyle(
                                                      fontWeight:
                                                          FontWeight.w600,
                                                      fontSize: 16,
                                                    ),
                                                  ),
                                                  Text(
                                                    'Spotify Family Plan',
                                                    style: Theme.of(context)
                                                        .textTheme
                                                        .bodySmall
                                                        ?.copyWith(
                                                          color:
                                                              Theme.of(context)
                                                                  .colorScheme
                                                                  .outline,
                                                        ),
                                                  ),
                                                ],
                                              ),
                                            ),
                                          ],
                                        ),
                                      ),
                                      const Divider(),
                                      ListTile(
                                        leading: Icon(
                                          Icons.edit,
                                          color: Theme.of(context)
                                              .colorScheme
                                              .primary,
                                        ),
                                        title: const Text('Rename Plan'),
                                        onTap: () {
                                          Navigator.pop(context);
                                          _showEditGroupDialog(context, group);
                                        },
                                      ),
                                      ListTile(
                                        leading: const Icon(
                                          Icons.delete_forever,
                                          color: Colors.red,
                                        ),
                                        title: const Text(
                                          'Delete Plan',
                                          style: TextStyle(color: Colors.red),
                                        ),
                                        subtitle: const Text(
                                          'This action cannot be undone',
                                          style: TextStyle(color: Colors.red),
                                        ),
                                        onTap: () {
                                          Navigator.pop(context);
                                          _showDeleteGroupDialog(
                                              context, group);
                                        },
                                      ),
                                      const SizedBox(height: 8),
                                    ],
                                  ),
                                ),
                              );
                            },
                          ),
                        ],
                      ),
                    ),
                  ),
                ),
              );
            },
          );
        },
      ),
      floatingActionButton: FloatingActionButton(
        onPressed: () => _showAddGroupDialog(context),
        child: const Icon(Icons.add),
      ),
    );
  }

  Future<void> _navigateToGroupDetails(
      BuildContext context, DocumentSnapshot group) async {
    print('\nNavigating to group details: ${group['groupName']}');

    // Show loading dialog
    showDialog(
      context: context,
      barrierDismissible: false,
      builder: (BuildContext context) {
        return Center(
          child: Card(
            child: Padding(
              padding: const EdgeInsets.all(20.0),
              child: Column(
                mainAxisSize: MainAxisSize.min,
                children: [
                  const CircularProgressIndicator(),
                  const SizedBox(height: 16),
                  Text(
                    'Loading ${group['groupName']}',
                    style: Theme.of(context).textTheme.titleMedium,
                  ),
                  const SizedBox(height: 8),
                  Text(
                    'Fetching members and payment status...',
                    style: Theme.of(context).textTheme.bodySmall?.copyWith(
                          color: Theme.of(context).colorScheme.outline,
                        ),
                  ),
                ],
              ),
            ),
          ),
        );
      },
    );

    // Pre-fetch the members data
    final membersCollection = FirebaseFirestore.instance
        .collection('groups1')
        .doc(group.id)
        .collection('members');

    try {
      print('Pre-fetching members data...');
      // Wait for initial data fetch
      final membersSnapshot = await membersCollection.get();
      print('Found ${membersSnapshot.docs.length} members');

      // Pop the loading dialog
      Navigator.pop(context);

      // Navigate to group details
      Navigator.push(
        context,
        MaterialPageRoute(
          builder: (context) => GroupDetailScreen(
            groupName: group['groupName'],
            groupId: group.id,
          ),
        ),
      );
    } catch (error) {
      print('Error loading group details: $error');
      // Pop the loading dialog
      Navigator.pop(context);

      // Show error message
      ScaffoldMessenger.of(context).showSnackBar(
        SnackBar(
          content: Text('Error loading group: $error'),
          backgroundColor: Colors.red,
        ),
      );
    }
  }

  void _showDeleteGroupDialog(BuildContext context, DocumentSnapshot group) {
    print('\nShowing delete confirmation for group: ${group['groupName']}');
    showDialog(
      context: context,
      builder: (context) => AlertDialog(
        title: Row(
          children: [
            const Icon(Icons.warning, color: Colors.red),
            const SizedBox(width: 8),
            const Text('Delete Group'),
          ],
        ),
        content: Text(
            'Are you sure you want to delete "${group['groupName']}"?\nThis action cannot be undone.'),
        actions: [
          TextButton(
            onPressed: () {
              print('Delete cancelled');
              Navigator.pop(context);
            },
            child: const Text('Cancel'),
          ),
          FilledButton(
            onPressed: () async {
              print('Deleting group...');
              try {
                await group.reference.delete();
                print('Group deleted successfully');
                Navigator.pop(context);
                ScaffoldMessenger.of(context).showSnackBar(
                  const SnackBar(
                    content: Text('Group deleted successfully'),
                    backgroundColor: Colors.green,
                  ),
                );
              } catch (e) {
                print('Error deleting group: $e');
                Navigator.pop(context);
                ScaffoldMessenger.of(context).showSnackBar(
                  SnackBar(
                    content: Text('Error deleting group: $e'),
                    backgroundColor: Colors.red,
                  ),
                );
              }
            },
            style: FilledButton.styleFrom(
              backgroundColor: Colors.red,
            ),
            child: const Text('Delete'),
          ),
        ],
      ),
    );
  }

  void _showAddGroupDialog(BuildContext context) {
    print('\nShowing add group dialog');
    final TextEditingController groupNameController = TextEditingController();

    showDialog(
      context: context,
      builder: (context) => AlertDialog(
        shape: RoundedRectangleBorder(
          borderRadius: BorderRadius.circular(16),
        ),
        title: Row(
          children: [
            Icon(
              Icons.group_add,
              color: Theme.of(context).colorScheme.primary,
            ),
            const SizedBox(width: 8),
            const Text('Add New Group'),
          ],
        ),
        content: Column(
          mainAxisSize: MainAxisSize.min,
          crossAxisAlignment: CrossAxisAlignment.start,
          children: [
            TextField(
              controller: groupNameController,
              decoration: InputDecoration(
                hintText: 'Group Name',
                filled: true,
                fillColor: Theme.of(context).colorScheme.surfaceVariant,
                border: OutlineInputBorder(
                  borderRadius: BorderRadius.circular(12),
                  borderSide: BorderSide.none,
                ),
                prefixIcon: const Icon(Icons.group),
              ),
              textCapitalization: TextCapitalization.words,
            ),
            const SizedBox(height: 8),
            Text(
              'Enter a name for your new group',
              style: Theme.of(context).textTheme.bodySmall?.copyWith(
                    color: Theme.of(context).colorScheme.outline,
                  ),
            ),
          ],
        ),
        actions: [
          TextButton(
            onPressed: () {
              print('Add group cancelled');
              Navigator.pop(context);
            },
            child: const Text('Cancel'),
          ),
          FilledButton(
            onPressed: () async {
              final groupName = groupNameController.text.trim();
              if (groupName.isNotEmpty) {
                print('Creating new group: $groupName');
                try {
                  // Create the group
                  final docRef =
                      await groupsCollection.add({'groupName': groupName});
                  print('Group created with ID: ${docRef.id}');

                  // Initialize with current month
                  String currentMonth =
                      DateTime.now().toString().substring(0, 7);
                  print('Initializing with month: $currentMonth');

                  // Create a dummy document to initialize the members collection
                  await docRef.collection('members').add({
                    'name': 'Dummy',
                    'phoneNumber': '0000000000',
                    'groupId': docRef.id,
                    'payments': {currentMonth: false},
                    'forwarded': false,
                  });
                  print('Initialized members collection');

                  Navigator.pop(context);
                  ScaffoldMessenger.of(context).showSnackBar(
                    const SnackBar(
                      content: Text('Group created successfully'),
                      backgroundColor: Colors.green,
                    ),
                  );
                } catch (e) {
                  print('Error creating group: $e');
                  ScaffoldMessenger.of(context).showSnackBar(
                    SnackBar(
                      content: Text('Error creating group: $e'),
                      backgroundColor: Colors.red,
                    ),
                  );
                }
              } else {
                print('Group name is empty');
                ScaffoldMessenger.of(context).showSnackBar(
                  const SnackBar(
                    content: Text('Please enter a group name'),
                    backgroundColor: Colors.orange,
                  ),
                );
              }
            },
            child: const Text('Create'),
          ),
        ],
      ),
    );
  }

  void _showEditGroupDialog(BuildContext context, DocumentSnapshot group) {
    print('\nShowing edit dialog for group: ${group['groupName']}');
    final TextEditingController groupNameController =
        TextEditingController(text: group['groupName']);

    showDialog(
      context: context,
      builder: (context) => AlertDialog(
        shape: RoundedRectangleBorder(
          borderRadius: BorderRadius.circular(16),
        ),
        title: Row(
          children: [
            Icon(
              Icons.edit,
              color: Theme.of(context).colorScheme.primary,
            ),
            const SizedBox(width: 8),
            const Text('Edit Group'),
          ],
        ),
        content: Column(
          mainAxisSize: MainAxisSize.min,
          crossAxisAlignment: CrossAxisAlignment.start,
          children: [
            TextField(
              controller: groupNameController,
              decoration: InputDecoration(
                hintText: 'Group Name',
                filled: true,
                fillColor: Theme.of(context).colorScheme.surfaceVariant,
                border: OutlineInputBorder(
                  borderRadius: BorderRadius.circular(12),
                  borderSide: BorderSide.none,
                ),
                prefixIcon: const Icon(Icons.group),
              ),
              textCapitalization: TextCapitalization.words,
            ),
            const SizedBox(height: 8),
            Text(
              'Update the group name',
              style: Theme.of(context).textTheme.bodySmall?.copyWith(
                    color: Theme.of(context).colorScheme.outline,
                  ),
            ),
          ],
        ),
        actions: [
          TextButton(
            onPressed: () {
              print('Edit cancelled');
              Navigator.pop(context);
            },
            child: const Text('Cancel'),
          ),
          FilledButton(
            onPressed: () async {
              final groupName = groupNameController.text.trim();
              if (groupName.isNotEmpty) {
                print('Updating group name to: $groupName');
                try {
                  await group.reference.update({'groupName': groupName});
                  print('Group updated successfully');
                  Navigator.pop(context);
                  ScaffoldMessenger.of(context).showSnackBar(
                    const SnackBar(
                      content: Text('Group updated successfully'),
                      backgroundColor: Colors.green,
                    ),
                  );
                } catch (e) {
                  print('Error updating group: $e');
                  ScaffoldMessenger.of(context).showSnackBar(
                    SnackBar(
                      content: Text('Error updating group: $e'),
                      backgroundColor: Colors.red,
                    ),
                  );
                }
              } else {
                print('Group name is empty');
                ScaffoldMessenger.of(context).showSnackBar(
                  const SnackBar(
                    content: Text('Group name cannot be empty'),
                    backgroundColor: Colors.orange,
                  ),
                );
              }
            },
            child: const Text('Update'),
          ),
        ],
      ),
    );
  }
}

class GroupDetailScreen extends StatefulWidget {
  final String groupName;
  final String groupId;

  const GroupDetailScreen({
    super.key,
    required this.groupName,
    required this.groupId,
  });

  @override
  State<GroupDetailScreen> createState() => _GroupDetailScreenState();
}

class _GroupDetailScreenState extends State<GroupDetailScreen> {
  bool isInitializing = true;
  String selectedMonth = '';
  List<String> availableMonths = [];
  List<DocumentSnapshot> pendingMembers = [];
  Timer? _statusCheckTimer;
  String _botStatus = 'offline';
  bool _isInitialized = false;
  double _uptime = 0;

  @override
  void initState() {
    super.initState();
    _initializeData();
    _startBotStatusCheck();
  }

  @override
  void dispose() {
    _statusCheckTimer?.cancel();
    super.dispose();
  }

  Future<void> _checkBotStatus() async {
    try {
      final url = Uri.parse("https://nodejs-test-hosting.onrender.com/");
      final response = await http.get(url);

      if (response.statusCode == 200) {
        final data = jsonDecode(response.body);
        setState(() {
          _botStatus = data['status'] ?? 'offline';
          _isInitialized = data['initialized'] ?? false;
          _uptime = (data['uptime'] ?? 0).toDouble();

          // If bot is running and initialized, stop the timer
          if (_botStatus == 'running' && _isInitialized) {
            _statusCheckTimer?.cancel();
          }
        });
      }
    } catch (e) {
      setState(() {
        _botStatus = 'error';
      });
    }
  }

  void _startBotStatusCheck() {
    _checkBotStatus();
    _statusCheckTimer?.cancel();
    _statusCheckTimer = Timer.periodic(const Duration(seconds: 10), (timer) {
      _checkBotStatus();
    });
  }

  Future<void> _initializeData() async {
    try {
      await _fetchAvailableMonths();
      await _fetchPendingMembers();

      // Set appropriate month based on current date
      if (selectedMonth == null && availableMonths.isNotEmpty) {
        final now = DateTime.now();
        String targetMonth;

        if (now.day < 20) {
          // If before 20th, use previous month
          final prevMonth = DateTime(now.year, now.month - 1);
          targetMonth =
              '${prevMonth.year}-${prevMonth.month.toString().padLeft(2, '0')}';
        } else {
          // If 20th or later, use current month
          targetMonth = '${now.year}-${now.month.toString().padLeft(2, '0')}';
        }

        print('Current date: ${now.toString()}');
        print('Target month based on 20th rule: $targetMonth');

        // Use target month if available, otherwise use latest available month
        if (availableMonths.contains(targetMonth)) {
          selectedMonth = targetMonth;
          print('Selected target month: $targetMonth');
        } else {
          selectedMonth = availableMonths.last;
          print(
              'Target month not available, using latest month: ${availableMonths.last}');
        }
      }

      // Run automatic payment marking
      if (selectedMonth != null) {
        await processAutomaticPayments();
      }
    } finally {
      if (mounted) {
        setState(() {
          isInitializing = false;
        });
      }
    }
  }

  Future<void> _fetchPendingMembers() async {
    if (selectedMonth == null) return;

    final snapshot = await FirebaseFirestore.instance
        .collection('groups1')
        .doc(widget.groupId)
        .collection('members')
        .where('payments.$selectedMonth', isEqualTo: false)
        .get();

    setState(() {
      pendingMembers = snapshot.docs;
      print('Pending Members Updated: ${pendingMembers.length}');
    });
  }

  Future<void> _fetchAvailableMonths() async {
    QuerySnapshot snapshot = await FirebaseFirestore.instance
        .collection('groups1')
        .doc(widget.groupId)
        .collection('members')
        .get();
    final allMonths = <String>{};

    if (snapshot.docs.isEmpty) {
      // If no members exist, initialize with appropriate month based on 20th rule
      final now = DateTime.now();
      String defaultMonth;
      if (now.day < 20) {
        // If before 20th, use previous month
        final prevMonth = DateTime(now.year, now.month - 1);
        defaultMonth =
            '${prevMonth.year}-${prevMonth.month.toString().padLeft(2, '0')}';
      } else {
        // If 20th or later, use current month
        defaultMonth = '${now.year}-${now.month.toString().padLeft(2, '0')}';
      }
      allMonths.add(defaultMonth);
    } else {
      for (var member in snapshot.docs) {
        final payments = member['payments'] ?? {};
        allMonths.addAll(payments.keys.cast<String>());
      }
    }

    if (mounted) {
      setState(() {
        availableMonths = allMonths.toList()..sort();

        // Set default month based on 20th rule
        final now = DateTime.now();
        String targetMonth;

        if (now.day < 20) {
          // If before 20th, use previous month
          if (now.month == 1) {
            // If January, go back to December of previous year
            targetMonth = '${now.year - 1}-12';
          } else {
            // Otherwise use previous month of same year
            targetMonth =
                '${now.year}-${(now.month - 1).toString().padLeft(2, '0')}';
          }
        } else {
          // If 20th or later, use current month
          targetMonth = '${now.year}-${now.month.toString().padLeft(2, '0')}';
        }

        print('Current date: ${now.toString()}');
        print('Target month based on 20th rule: $targetMonth');

        // Use target month if available, otherwise use latest available month
        selectedMonth = availableMonths.isNotEmpty
            ? availableMonths.contains(targetMonth)
                ? targetMonth
                : availableMonths.last
            : targetMonth;

        print('Selected month: $selectedMonth');
      });
    }
  }

  // Method to calculate the next month based on the current one
  String _getNextMonth(String latestMonth) {
    List<String> parts = latestMonth.split('-');
    int year = int.parse(parts[0]);
    int month = int.parse(parts[1]);

    if (month == 12) {
      year += 1;
      month = 1;
    } else {
      month += 1;
    }

    return "$year-${month.toString().padLeft(2, '0')}";
  }

  // Add new month to all members
  void _addNewMonth() async {
    if (availableMonths.isEmpty) {
      // If this is a new group with no months, initialize with current month
      String currentMonth = DateTime.now().toString().substring(0, 7);
      String newMonth = currentMonth;
      await _initializeNewGroup(newMonth);
    } else {
      // Get the latest month and calculate next month
      String latestMonth = availableMonths.last;
      String newMonth = _getNextMonth(latestMonth);

      // Get all groups
      final groupsCollection = FirebaseFirestore.instance.collection('groups1');
      final groups = await groupsCollection.get();

      // Update all groups
      for (var group in groups.docs) {
        final membersRef = group.reference.collection('members');
        final members = await membersRef.get();

        // Update all members in this group
        for (var member in members.docs) {
          await membersRef.doc(member.id).update({
            'payments.$newMonth': false,
          });
        }
      }

      // Update UI
      setState(() {
        availableMonths.add(newMonth);
        selectedMonth = newMonth;
      });
    }
  }

  // New method to initialize a new group
  Future<void> _initializeNewGroup(String initialMonth) async {
    setState(() {
      availableMonths = [initialMonth];
      selectedMonth = initialMonth;
    });
  }

  Future<void> sendPostRequest(String endpoint,
      {Map<String, dynamic>? body}) async {
    try {
      final url =
          Uri.parse("https://nodejs-test-hosting.onrender.com/$endpoint");
      final response = await http.post(
        url,
        headers: {
          'Content-Type': 'application/json',
        },
        body: body != null ? jsonEncode(body) : null,
      );

      if (response.statusCode == 200) {
        _showSnackBar("Success: ${response.body}");
      } else {
        _showSnackBar("Error: ${response.statusCode} - ${response.body}");
      }
    } catch (e) {
      _showSnackBar("Error: $e");
    }
  }

  Future<void> _mentionPendingUsers() async {
    // Fetch latest pending members before proceeding
    await _fetchPendingMembers();

    if (pendingMembers.isEmpty) {
      _showSnackBar('No pending users to mention');
      return;
    }

    setState(() {
      isInitializing = true;
    });

    try {
      // Find a pending member to get their groupId
      final pendingMember = await FirebaseFirestore.instance
          .collection('groups1')
          .doc(widget.groupId)
          .collection('members')
          .where('phoneNumber',
              whereIn: pendingMembers
                  .map((doc) => doc['phoneNumber'] as String)
                  .toList())
          .where('payments.$selectedMonth', isEqualTo: false)
          .limit(1)
          .get();

      if (pendingMember.docs.isEmpty) {
        throw Exception('No pending members found');
      }

      final String memberGroupId = pendingMember.docs.first['groupId'];
      final userNumbers =
          pendingMembers.map((doc) => doc['phoneNumber'] as String).toList();

      await sendPostRequest(
        "mention-users",
        body: {
          "groupId": memberGroupId,
          "userNumbers": userNumbers,
          "messageType": "pending",
        },
      );
    } catch (error) {
      _showSnackBar('Error mentioning users: ${error.toString()}');
    } finally {
      setState(() {
        isInitializing = false;
      });
    }
  }

  Future<void> _mentionPaidUsers() async {
    if (isInitializing) return;

    setState(() {
      isInitializing = true;
    });

    try {
      // Get paid members who haven't been forwarded yet
      final paidMembers = await FirebaseFirestore.instance
          .collection('groups1')
          .doc(widget.groupId)
          .collection('members')
          .where('payments.$selectedMonth', isEqualTo: true)
          .where('forwarded', isEqualTo: false)
          .get();

      if (paidMembers.docs.isEmpty) {
        _showSnackBar('No new paid members to forward');
        return;
      }

      // Get groupId from the first member
      final String memberGroupId = paidMembers.docs.first['groupId'];

      // Extract phone numbers
      final userNumbers = paidMembers.docs
          .map((doc) => doc['phoneNumber'] as String)
          .map((phone) => phone.replaceAll(RegExp(r'\D'), ''))
          .toList();

      // Send the post request
      await sendPostRequest(
        "mention-users",
        body: {
          "groupId": memberGroupId,
          "userNumbers": userNumbers,
          "messageType": "paid",
        },
      );

      // Mark these members as forwarded
      for (var doc in paidMembers.docs) {
        await doc.reference.update({'forwarded': true});
      }

      _showSnackBar(
          'Successfully forwarded ${userNumbers.length} paid members');
    } catch (error) {
      _showSnackBar('Error forwarding paid members: ${error.toString()}');
    } finally {
      setState(() {
        isInitializing = false;
      });
    }
  }

  // Show a snack bar with the response message
  void _showSnackBar(String message) {
    ScaffoldMessenger.of(context).showSnackBar(
      SnackBar(content: Text(message)),
    );
  }

  // Add this method to process SMS messages
  Future<void> processAutomaticPayments() async {
    if (selectedMonth == null) {
      _showSnackBar('Please select a month first');
      return;
    }

    setState(() {
      isInitializing = true;
    });

    try {
      print('\n=== Starting SMS Processing ===');

      // Get all messages first
      final messages = await SmsQuery().querySms(
        kinds: [SmsQueryKind.inbox],
      );

      print('Total messages found: ${messages.length}');

      // Filter for SBI UPI messages
      final sbiMessages = messages
          .where((msg) => (msg.address ?? '').toUpperCase().contains('SBIUPI'))
          .toList();

      print('SBI UPI messages found: ${sbiMessages.length}');

      // Get pending members
      final pendingMembers = await FirebaseFirestore.instance
          .collection('groups1')
          .doc(widget.groupId)
          .collection('members')
          .where('payments.$selectedMonth', isEqualTo: false)
          .get();

      print('Pending members found: ${pendingMembers.docs.length}');

      int markedCount = 0;
      List<String> processedMembers = [];

      // Process each message
      for (var message in sbiMessages) {
        if (message.body == null) continue;

        print('\nProcessing message: ${message.body}');

        // Extract date and amount from message
        final RegExp dateRegex =
            RegExp(r'on (\d{2})([A-Za-z]{3})(\d{2})', caseSensitive: false);
        final RegExp amountRegex =
            RegExp(r'Rs\.?(\d+(?:\.\d{1,2})?)', caseSensitive: false);
        final RegExp senderRegex = RegExp(
            r'(?:from|by) ([A-Za-z\s]+)(?=\s+(?:Ref|UPI|on|$))',
            caseSensitive: false);
        final RegExp refRegex = RegExp(r'Ref No (\d+)', caseSensitive: false);

        final dateMatch = dateRegex.firstMatch(message.body!);
        final amountMatch = amountRegex.firstMatch(message.body!);
        final senderMatch = senderRegex.firstMatch(message.body!);
        final refMatch = refRegex.firstMatch(message.body!);

        if (dateMatch == null || amountMatch == null || senderMatch == null) {
          print('Skipping message - Missing required information');
          continue;
        }

        final day = int.tryParse(dateMatch.group(1) ?? '');
        final monthStr = dateMatch.group(2)?.toLowerCase();
        final year = int.tryParse(dateMatch.group(3) ?? '');
        final amount = amountMatch.group(1);
        final sender = senderMatch.group(1)?.trim();
        final refNo = refMatch?.group(1);

        print('Extracted data:');
        print('Date: $day-$monthStr-$year');
        print('Amount: Rs.$amount');
        print('Sender: $sender');
        print('Ref No: $refNo');

        if (day == null || monthStr == null || year == null || sender == null) {
          print('Skipping message - Invalid data');
          continue;
        }

        // Convert month abbreviation to number
        final monthMap = {
          'jan': 1,
          'feb': 2,
          'mar': 3,
          'apr': 4,
          'may': 5,
          'jun': 6,
          'jul': 7,
          'aug': 8,
          'sep': 9,
          'oct': 10,
          'nov': 11,
          'dec': 12
        };

        final month = monthMap[monthStr];
        if (month == null) continue;

        // Convert to full year (assuming 20xx)
        final fullYear = 2000 + year;

        // Determine which month this payment belongs to based on the date
        String paymentMonth;
        if (day >= 20) {
          // If date is 20th or later, it belongs to current month
          paymentMonth = '$fullYear-${month.toString().padLeft(2, '0')}';
        } else {
          // If date is before 20th, it belongs to previous month
          if (month == 1) {
            // If it's January, previous month is December of last year
            paymentMonth = '${fullYear - 1}-12';
          } else {
            // Otherwise, just previous month of same year
            paymentMonth =
                '$fullYear-${(month - 1).toString().padLeft(2, '0')}';
          }
        }

        print('Payment belongs to month: $paymentMonth');

        // Check if message is for selected month
        if (paymentMonth != selectedMonth) {
          print(
              'Skipping message - Wrong month ($paymentMonth != $selectedMonth)');
          continue;
        }

        // Check each pending member
        for (var member in pendingMembers.docs) {
          final bankingName = member['bankingName']?.toString().toLowerCase();
          if (bankingName == null || bankingName.isEmpty) {
            print('Skipping member ${member['name']} - No banking name');
            continue;
          }

          final senderLower = sender.toLowerCase();
          if (senderLower.contains(bankingName)) {
            // Check payment amount if set
            final expectedAmount = member['paymentAmount'];
            if (expectedAmount != null) {
              final transactionAmount = double.tryParse(amount ?? '0');
              if (transactionAmount == null ||
                  transactionAmount != expectedAmount) {
                print(
                    'Amount mismatch for ${member['name']}: Expected Rs.$expectedAmount, got Rs.$amount');
                continue;
              }
            }

            print('Match found! Marking ${member['name']} as paid');

            // Create payment note
            final paymentNote =
                'Auto-marked: Rs.$amount received from $sender' +
                    (refNo != null ? ' (Ref: $refNo)' : '');

            await member.reference.update({
              'payments.$selectedMonth': true,
              'forwarded': false,
              'paymentNotes.$selectedMonth': paymentNote,
            });

            markedCount++;
            processedMembers.add('${member['name']} (Rs.$amount)');
            break;
          }
        }
      }

      if (markedCount > 0) {
        _showSnackBar(
            'Marked $markedCount payments:\n${processedMembers.join("\n")}');
      } else {
        _showSnackBar('No matching transactions found');
      }
    } catch (e) {
      print('Error processing payments: $e');
      _showSnackBar('Error: $e');
    } finally {
      setState(() {
        isInitializing = false;
      });
      await _fetchPendingMembers();
    }
  }

  // Add method to process a single SMS message
  Future<void> processSingleSms(SmsMessage message) async {
    if (selectedMonth == null) return;

    try {
      // Parse the date from message body (format: ddMMMYY)
      final RegExp dateRegex = RegExp(r'(\d{2})([A-Za-z]{3})(\d{2})');
      final dateMatch = dateRegex.firstMatch(message.body ?? '');

      if (dateMatch == null) return;

      final day = dateMatch.group(1);
      final monthStr = dateMatch.group(2)?.toLowerCase();
      final year = dateMatch.group(3);

      if (day == null || monthStr == null || year == null) return;

      // Convert month abbreviation to number
      final monthMap = {
        'jan': 1,
        'feb': 2,
        'mar': 3,
        'apr': 4,
        'may': 5,
        'jun': 6,
        'jul': 7,
        'aug': 8,
        'sep': 9,
        'oct': 10,
        'nov': 11,
        'dec': 12
      };

      final month = monthMap[monthStr];
      if (month == null) return;

      // Convert to full year (assuming 20xx)
      final fullYear = 2000 + int.parse(year);

      // Format the date to match our month format (YYYY-MM)
      final messageMonth = '$fullYear-${month.toString().padLeft(2, '0')}';

      // Skip if message is not from the selected month
      if (messageMonth != selectedMonth) return;

      // Get pending members for this month
      final pendingMembers = await FirebaseFirestore.instance
          .collection('groups1')
          .doc(widget.groupId)
          .collection('members')
          .where('payments.$selectedMonth', isEqualTo: false)
          .get();

      // Process each pending member
      for (var member in pendingMembers.docs) {
        final bankingName = member['bankingName'];
        if (bankingName == null || bankingName.isEmpty) continue;

        // Check if the message contains the member's banking name and is a credit transaction
        if (message.body!.toLowerCase().contains('credited') &&
            message.body!.toLowerCase().contains(bankingName.toLowerCase())) {
          // Mark the member as paid
          await member.reference.update({
            'payments.$selectedMonth': true,
            'forwarded': false,
          });
          _showSnackBar('Marked ${member['name']} as paid for $messageMonth');
          break;
        }
      }
    } catch (e) {
      print('Error processing single SMS: $e');
    }
  }

  // Add this method to print current month's messages
  Future<void> printCurrentMonthMessages() async {
    try {
      print('\n=== Starting SMS Debug ===');

      // Check if permission is granted
      final permissionStatus = await Permission.sms.status;
      print('Current SMS Permission Status: ${permissionStatus.toString()}');

      if (!permissionStatus.isGranted) {
        print('Requesting SMS Permission...');
        final result = await Permission.sms.request();
        print('Permission Request Result: ${result.toString()}');

        if (!result.isGranted) {
          print('Permission not granted. Cannot proceed.');
          _showSnackBar('SMS permission is required');
          return;
        }
      }

      setState(() {
        isInitializing = true;
      });

      print('\nAttempting to read ALL SMS messages...');

      try {
        // First try to read any SMS message
        final allMessages = await SmsQuery().querySms(
          kinds: [SmsQueryKind.inbox],
          count: 10, // Just try to read 10 messages first
        );

        print('Successfully read ${allMessages.length} messages from inbox');
        if (allMessages.isNotEmpty) {
          print('\nFirst message details:');
          print('Address: ${allMessages[0].address}');
          print('Body: ${allMessages[0].body}');
        }

        // Now try to read all messages
        print('\nReading all SMS messages...');
        final messages = await SmsQuery().querySms(
          kinds: [SmsQueryKind.inbox],
        );
        print('Total SMS in inbox: ${messages.length}');

        // Print all unique sender addresses
        final senders = messages.map((m) => m.address).toSet();
        print('\nUnique sender addresses found:');
        senders.forEach((sender) => print(sender));

        // Filter SBIUPI messages
        final sbiMessages = messages.where((message) {
          final address = message.address ?? '';
          final isSbiUpi = address.endsWith('-SBIUPI');
          print('Checking address: $address, Is SBIUPI: $isSbiUpi');
          return isSbiUpi;
        }).toList();

        print('\n=== SBI UPI Messages ===');
        print('Total SBIUPI messages found: ${sbiMessages.length}');

        if (sbiMessages.isEmpty) {
          print('\nNo SBIUPI messages found. Showing sample of all messages:');
          for (var i = 0; i < 5 && i < messages.length; i++) {
            print('\nMessage ${i + 1}:');
            print('Sender: ${messages[i].address}');
            print('Body: ${messages[i].body}');
          }
          _showSnackBar(
              'No SBI UPI messages found. Check console for details.');
          return;
        }

        print('\nProcessing SBIUPI messages:');
        for (var message in sbiMessages) {
          print('\n-------------------');
          print('From: ${message.address}');
          print('Body: ${message.body}');
        }
      } catch (e, stack) {
        print('Error reading SMS messages: $e');
        print('Stack trace: $stack');
        _showSnackBar('Error reading SMS: $e');
      }

      print('\n=== End of SMS Debug ===');
    } catch (e, stack) {
      print('Top level error: $e');
      print('Stack trace: $stack');
      _showSnackBar('Error: $e');
    } finally {
      setState(() {
        isInitializing = false;
      });
    }
  }

  @override
  Widget build(BuildContext context) {
    if (isInitializing) {
      return Scaffold(
        appBar: AppBar(
          title: Text('${widget.groupName} Members'),
          backgroundColor: Theme.of(context).colorScheme.primaryContainer,
          elevation: 0,
        ),
        body: Center(
          child: Column(
            mainAxisAlignment: MainAxisAlignment.center,
            children: [
              const CircularProgressIndicator(),
              const SizedBox(height: 16),
              Text(
                'Loading Members...',
                style: Theme.of(context).textTheme.titleMedium,
              ),
              const SizedBox(height: 8),
              Text(
                'Checking payment status',
                style: Theme.of(context).textTheme.bodyMedium?.copyWith(
                      color: Theme.of(context).colorScheme.outline,
                    ),
              ),
            ],
          ),
        ),
      );
    }

    return Scaffold(
      appBar: AppBar(
        title: Row(
          children: [
            Icon(
              Icons.album,
              color: Theme.of(context).colorScheme.onPrimaryContainer,
            ),
            const SizedBox(width: 12),
            Expanded(
              child: Column(
                crossAxisAlignment: CrossAxisAlignment.start,
                children: [
                  Text(widget.groupName),
                  Text(
                    'Family Plan Members',
                    style: Theme.of(context).textTheme.bodySmall?.copyWith(
                          color: Theme.of(context)
                              .colorScheme
                              .onPrimaryContainer
                              .withOpacity(0.8),
                        ),
                  ),
                ],
              ),
            ),
          ],
        ),
        actions: [
          IconButton(
            icon: const Icon(Icons.refresh),
            tooltip: 'Refresh Everything',
            onPressed: () {
              print('Refreshing group details...');
              // Show loading indicator
              showDialog(
                context: context,
                barrierDismissible: false,
                builder: (context) => Center(
                  child: Card(
                    child: Padding(
                      padding: const EdgeInsets.all(16.0),
                      child: Column(
                        mainAxisSize: MainAxisSize.min,
                        children: [
                          const CircularProgressIndicator(),
                          const SizedBox(height: 16),
                          Text(
                            'Refreshing ${widget.groupName}...',
                            style: Theme.of(context).textTheme.titleMedium,
                          ),
                          const SizedBox(height: 8),
                          Text(
                            'Checking latest payments',
                            style: Theme.of(context)
                                .textTheme
                                .bodySmall
                                ?.copyWith(
                                  color: Theme.of(context).colorScheme.outline,
                                ),
                          ),
                        ],
                      ),
                    ),
                  ),
                ),
              );

              // Perform refresh operations
              Future.wait([
                _initializeData(),
                Future.delayed(
                    const Duration(milliseconds: 500)), // Minimum loading time
              ]).then((_) {
                // Pop loading dialog
                Navigator.pop(context);
                // Show success message
                ScaffoldMessenger.of(context).showSnackBar(
                  const SnackBar(
                    content: Text('Refreshed successfully'),
                    backgroundColor: Colors.green,
                  ),
                );
              }).catchError((error) {
                // Pop loading dialog
                Navigator.pop(context);
                // Show error message
                ScaffoldMessenger.of(context).showSnackBar(
                  SnackBar(
                    content: Text('Error refreshing: $error'),
                    backgroundColor: Colors.red,
                  ),
                );
              });
            },
          ),
        ],
        backgroundColor: Theme.of(context).colorScheme.primaryContainer,
        elevation: 0,
      ),
      body: Column(
        children: [
          Container(
            padding: const EdgeInsets.all(16),
            decoration: BoxDecoration(
              color: Theme.of(context).colorScheme.surface,
              boxShadow: [
                BoxShadow(
                  color: Colors.black.withOpacity(0.05),
                  blurRadius: 10,
                  offset: const Offset(0, 2),
                ),
              ],
            ),
            child: Column(
              crossAxisAlignment: CrossAxisAlignment.stretch,
              children: [
                // Month Selection Row
                Container(
                  padding: const EdgeInsets.symmetric(horizontal: 12),
                  decoration: BoxDecoration(
                    color: Theme.of(context).colorScheme.surface,
                    borderRadius: BorderRadius.circular(12),
                    border: Border.all(
                      color: Theme.of(context)
                          .colorScheme
                          .outline
                          .withOpacity(0.3),
                    ),
                  ),
                  child: Row(
                    children: [
                      Expanded(
                        child: DropdownButtonHideUnderline(
                          child: DropdownButton<String>(
                            hint: const Text('Select Month'),
                            value: selectedMonth,
                            isExpanded: true,
                            items: availableMonths.map((month) {
                              return DropdownMenuItem<String>(
                                value: month,
                                child: Text(month),
                              );
                            }).toList(),
                            onChanged: isInitializing
                                ? null
                                : (newMonth) {
                                    setState(() {
                                      selectedMonth = newMonth!;
                                      _fetchPendingMembers();
                                    });
                                  },
                          ),
                        ),
                      ),
                      IconButton(
                        icon: const Icon(Icons.add),
                        onPressed: isInitializing ? null : _addNewMonth,
                        tooltip: 'Add Next Month',
                      ),
                    ],
                  ),
                ),
                const SizedBox(height: 16),

                // Action Buttons in a Row
                Row(
                  children: [
                    Expanded(
                      child: _buildActionButton(
                        icon: Icons.account_balance,
                        label: 'Check\nPayments',
                        onPressed: processAutomaticPayments,
                        isProcessing: isInitializing,
                        processingLabel: 'Checking\nSMS...',
                      ),
                    ),
                    const SizedBox(width: 8),
                    Expanded(
                      child: _buildActionButton(
                        icon: Icons.notifications_active,
                        label: 'Remind\nPending',
                        onPressed: _mentionPendingUsers,
                        isProcessing: isInitializing,
                        processingLabel: 'Sending\nReminders...',
                      ),
                    ),
                    const SizedBox(width: 8),
                    Expanded(
                      child: _buildActionButton(
                        icon: Icons.check_circle,
                        label: 'Share\nPaid List',
                        onPressed: _mentionPaidUsers,
                        isProcessing: isInitializing,
                        processingLabel: 'Sharing\nList...',
                      ),
                    ),
                  ],
                ),

                if (isInitializing) ...[
                  const SizedBox(height: 16),
                  const LinearProgressIndicator(),
                ],
              ],
            ),
          ),

          // Members List
          Expanded(
            child: _buildMembersListView(),
          ),
        ],
      ),
      floatingActionButton: FloatingActionButton(
        onPressed: () => _showAddMemberDialog(),
        child: const Icon(Icons.person_add),
      ),
      floatingActionButtonLocation: FloatingActionButtonLocation.endFloat,
      bottomNavigationBar: BottomAppBar(
        height: 80,
        padding: const EdgeInsets.all(16),
        child: Row(
          mainAxisAlignment: MainAxisAlignment.center,
          children: [
            _BotStatusButton(
              status: _botStatus,
              isInitialized: _isInitialized,
              uptime: _uptime,
              onRefresh: _startBotStatusCheck,
            ),
          ],
        ),
      ),
    );
  }

  Widget _buildActionButton({
    required IconData icon,
    required String label,
    required VoidCallback onPressed,
    required bool isProcessing,
    required String processingLabel,
  }) {
    return ElevatedButton(
      onPressed: isProcessing ? null : onPressed,
      style: ElevatedButton.styleFrom(
        padding: const EdgeInsets.symmetric(vertical: 16),
        backgroundColor: Theme.of(context).colorScheme.surface,
        foregroundColor: Theme.of(context).colorScheme.primary,
        elevation: 0,
        shape: RoundedRectangleBorder(
          borderRadius: BorderRadius.circular(12),
          side: BorderSide(
            color: Theme.of(context).colorScheme.outline.withOpacity(0.3),
          ),
        ),
      ),
      child: Column(
        mainAxisSize: MainAxisSize.min,
        children: [
          if (isProcessing)
            SizedBox(
              width: 24,
              height: 24,
              child: CircularProgressIndicator(
                strokeWidth: 2,
                valueColor: AlwaysStoppedAnimation<Color>(
                  Theme.of(context).colorScheme.primary,
                ),
              ),
            )
          else
            Icon(icon, size: 24),
          const SizedBox(height: 4),
          Text(
            isProcessing ? processingLabel : label,
            textAlign: TextAlign.center,
            style: TextStyle(
              fontSize: 12,
              color: isProcessing
                  ? Theme.of(context).colorScheme.outline
                  : Theme.of(context).colorScheme.primary,
            ),
          ),
        ],
      ),
    );
  }

  // Member list UI
  Widget _buildMemberList(
    BuildContext context,
    String title,
    List<DocumentSnapshot> members,
  ) {
    return Padding(
      padding: const EdgeInsets.all(8.0),
      child: Column(
        crossAxisAlignment: CrossAxisAlignment.start,
        children: [
          Text(
            title,
            style: const TextStyle(fontSize: 18, fontWeight: FontWeight.bold),
          ),
          const SizedBox(height: 8),
          ListView.builder(
            shrinkWrap: true,
            physics: const NeverScrollableScrollPhysics(),
            itemCount: members.length,
            itemBuilder: (context, index) {
              final member = members[index];
              return ListTile(
                title: Text(member['name']),
                subtitle: Text('Phone: ${member['phoneNumber']}'),
                trailing: PopupMenuButton<String>(
                  onSelected: (value) {
                    if (value == 'Edit') {
                      _showEditMemberDialog(member);
                    } else if (value == 'Delete') {
                      _deleteMember(member);
                    }
                  },
                  itemBuilder: (context) => [
                    const PopupMenuItem(
                      value: 'Edit',
                      child: Text('Edit'),
                    ),
                    const PopupMenuItem(
                      value: 'Delete',
                      child: Text('Delete'),
                    ),
                  ],
                ),
                leading: IconButton(
                  icon: Icon(
                    (member['payments'][selectedMonth] ?? false)
                        ? Icons.check_circle
                        : Icons.check_circle_outline,
                    color: (member['payments'][selectedMonth] ?? false)
                        ? Colors.green
                        : Colors.grey,
                  ),
                  onPressed: () {
                    FirebaseFirestore.instance
                        .collection('groups1')
                        .doc(widget.groupId)
                        .collection('members')
                        .doc(member.id)
                        .update({
                      'payments.$selectedMonth':
                          !(member['payments'][selectedMonth] ?? false),
                    });
                  },
                ),
              );
            },
          ),
        ],
      ),
    );
  }

  // Edit Member Dialog
  void _showEditMemberDialog(DocumentSnapshot member) {
    final TextEditingController nameController =
        TextEditingController(text: member['name']);
    final TextEditingController phoneController =
        TextEditingController(text: member['phoneNumber']);
    final TextEditingController groupIdController =
        TextEditingController(text: member['groupId'] ?? '');
    final TextEditingController bankingNameController =
        TextEditingController(text: member['bankingName'] ?? '');
    final TextEditingController amountController =
        TextEditingController(text: member['paymentAmount']?.toString() ?? '');

    showDialog(
      context: context,
      builder: (context) => AlertDialog(
        title: const Text('Edit Member'),
        content: Column(
          mainAxisSize: MainAxisSize.min,
          children: [
            TextField(
              controller: nameController,
              decoration: const InputDecoration(hintText: 'Name'),
            ),
            const SizedBox(height: 8),
            TextField(
              controller: phoneController,
              decoration: const InputDecoration(hintText: 'Phone Number'),
              keyboardType: TextInputType.phone,
            ),
            const SizedBox(height: 8),
            TextField(
              controller: groupIdController,
              decoration: const InputDecoration(hintText: 'Group ID'),
            ),
            const SizedBox(height: 8),
            TextField(
              controller: bankingNameController,
              decoration: const InputDecoration(
                hintText: 'Banking Name (Optional)',
                helperText: 'Name as it appears in bank transactions',
              ),
            ),
            const SizedBox(height: 8),
            TextField(
              controller: amountController,
              decoration: const InputDecoration(
                hintText: 'Payment Amount',
                helperText: 'Monthly payment amount to check in transactions',
              ),
              keyboardType: TextInputType.number,
            ),
          ],
        ),
        actions: [
          TextButton(
            onPressed: () {
              Navigator.pop(context);
            },
            child: const Text('Cancel'),
          ),
          TextButton(
            onPressed: () {
              final name = nameController.text.trim();
              final phone = phoneController.text.trim();
              final groupId = groupIdController.text.trim();
              final bankingName = bankingNameController.text.trim();
              final amountText = amountController.text.trim();

              if (name.isNotEmpty && phone.isNotEmpty && groupId.isNotEmpty) {
                // Parse amount if provided
                double? amount;
                if (amountText.isNotEmpty) {
                  amount = double.tryParse(amountText);
                  if (amount == null) {
                    ScaffoldMessenger.of(context).showSnackBar(
                      const SnackBar(content: Text('Invalid payment amount')),
                    );
                    return;
                  }
                }

                member.reference.update({
                  'name': name,
                  'phoneNumber': phone,
                  'groupId': groupId,
                  'bankingName': bankingName.isNotEmpty ? bankingName : null,
                  'paymentAmount': amount,
                });

                Navigator.pop(context);
                ScaffoldMessenger.of(context).showSnackBar(
                  const SnackBar(content: Text('Member updated successfully')),
                );
              } else {
                ScaffoldMessenger.of(context).showSnackBar(
                  const SnackBar(
                      content: Text('Required fields cannot be empty!')),
                );
              }
            },
            child: const Text('Save'),
          ),
        ],
      ),
    );
  }

  // Delete Member
  void _deleteMember(DocumentSnapshot member) {
    showDialog(
      context: context,
      builder: (context) => AlertDialog(
        title: const Text('Delete Member'),
        content: const Text('Are you sure you want to delete this member?'),
        actions: [
          TextButton(
            onPressed: () {
              Navigator.pop(context);
            },
            child: const Text('Cancel'),
          ),
          TextButton(
            onPressed: () async {
              await member.reference.delete();
              Navigator.pop(context);
              ScaffoldMessenger.of(context).showSnackBar(
                const SnackBar(content: Text('Member deleted successfully')),
              );
            },
            child: const Text('Delete'),
          ),
        ],
      ),
    );
  }

  // Add Member Dialog
  void _showAddMemberDialog() {
    final TextEditingController nameController = TextEditingController();
    final TextEditingController phoneController = TextEditingController();
    final TextEditingController groupIdController = TextEditingController();
    final TextEditingController bankingNameController = TextEditingController();
    final TextEditingController amountController = TextEditingController();

    showDialog(
      context: context,
      builder: (context) => AlertDialog(
        title: const Text('Add New Member'),
        content: Column(
          mainAxisSize: MainAxisSize.min,
          children: [
            TextField(
              controller: nameController,
              decoration: const InputDecoration(hintText: 'Name'),
            ),
            const SizedBox(height: 8),
            TextField(
              controller: phoneController,
              decoration: const InputDecoration(hintText: 'Phone Number'),
              keyboardType: TextInputType.phone,
            ),
            const SizedBox(height: 8),
            TextField(
              controller: groupIdController,
              decoration: const InputDecoration(hintText: 'Group ID'),
            ),
            const SizedBox(height: 8),
            TextField(
              controller: bankingNameController,
              decoration: const InputDecoration(
                hintText: 'Banking Name (Optional)',
                helperText: 'Name as it appears in bank transactions',
              ),
            ),
            const SizedBox(height: 8),
            TextField(
              controller: amountController,
              decoration: const InputDecoration(
                hintText: 'Payment Amount',
                helperText: 'Monthly payment amount to check in transactions',
              ),
              keyboardType: TextInputType.number,
            ),
          ],
        ),
        actions: [
          TextButton(
            onPressed: () {
              Navigator.pop(context);
            },
            child: const Text('Cancel'),
          ),
          TextButton(
            onPressed: () async {
              final name = nameController.text.trim();
              final phone = phoneController.text.trim();
              final groupId = groupIdController.text.trim();
              final bankingName = bankingNameController.text.trim();
              final amountText = amountController.text.trim();

              if (name.isNotEmpty && phone.isNotEmpty && groupId.isNotEmpty) {
                // Parse amount if provided
                double? amount;
                if (amountText.isNotEmpty) {
                  amount = double.tryParse(amountText);
                  if (amount == null) {
                    ScaffoldMessenger.of(context).showSnackBar(
                      const SnackBar(content: Text('Invalid payment amount')),
                    );
                    return;
                  }
                }

                // Initialize the payments field with all existing months set to false
                final Map<String, bool> initialPayments = {
                  for (var month in availableMonths) month: false,
                };

                // Add the new member to Firestore
                await FirebaseFirestore.instance
                    .collection('groups1')
                    .doc(widget.groupId)
                    .collection('members')
                    .add({
                  'name': name,
                  'phoneNumber': phone,
                  'groupId': groupId,
                  'bankingName': bankingName.isNotEmpty ? bankingName : null,
                  'paymentAmount': amount,
                  'payments': initialPayments,
                  'forwarded': false,
                });

                Navigator.pop(context);
                ScaffoldMessenger.of(context).showSnackBar(
                  const SnackBar(content: Text('Member added successfully')),
                );
              } else {
                ScaffoldMessenger.of(context).showSnackBar(
                  const SnackBar(
                      content: Text('Required fields cannot be empty!')),
                );
              }
            },
            child: const Text('Add'),
          ),
        ],
      ),
    );
  }

  Widget _buildMembersListView() {
    return StreamBuilder<QuerySnapshot>(
      stream: FirebaseFirestore.instance
          .collection('groups1')
          .doc(widget.groupId)
          .collection('members')
          .snapshots(),
      builder: (context, snapshot) {
        if (snapshot.connectionState == ConnectionState.waiting) {
          return const Center(
            child: CircularProgressIndicator(),
          );
        }

        if (!snapshot.hasData || snapshot.data!.docs.isEmpty) {
          return Center(
            child: Column(
              mainAxisAlignment: MainAxisAlignment.center,
              children: [
                Icon(
                  Icons.people_outline,
                  size: 64,
                  color: Theme.of(context).colorScheme.secondary,
                ),
                const SizedBox(height: 16),
                const Text(
                  'No Members Found',
                  style: TextStyle(fontSize: 18),
                ),
              ],
            ),
          );
        }

        final members = snapshot.data!.docs;
        final filteredMembers = members.where((member) {
          final payments = member['payments'] ?? {};
          return selectedMonth == null || payments[selectedMonth] != null;
        }).toList();

        final paidMembers = filteredMembers
            .where((member) => member['payments'][selectedMonth] ?? false)
            .toList();
        final pendingMembers = filteredMembers
            .where((member) => !(member['payments'][selectedMonth] ?? false))
            .toList();

        return ListView(
          padding: const EdgeInsets.all(16),
          children: [
            _buildMemberSection(
              context,
              'Paid Members',
              paidMembers,
              Icons.check_circle,
              Colors.green,
            ),
            const SizedBox(height: 24),
            _buildMemberSection(
              context,
              'Pending Members',
              pendingMembers,
              Icons.pending,
              Colors.orange,
            ),
          ],
        );
      },
    );
  }

  Widget _buildMemberSection(
    BuildContext context,
    String title,
    List<DocumentSnapshot> members,
    IconData icon,
    Color iconColor,
  ) {
    return Column(
      crossAxisAlignment: CrossAxisAlignment.start,
      children: [
        Padding(
          padding: const EdgeInsets.symmetric(horizontal: 16, vertical: 8),
          child: Row(
            children: [
              Icon(icon, color: iconColor, size: 20),
              const SizedBox(width: 8),
              Text(
                title == 'Paid Members'
                    ? 'Premium Members'
                    : 'Pending Payments',
                style: Theme.of(context).textTheme.titleMedium?.copyWith(
                      fontWeight: FontWeight.w600,
                    ),
              ),
              const SizedBox(width: 8),
              Text(
                '(${members.length})',
                style: Theme.of(context).textTheme.titleMedium?.copyWith(
                      color: Theme.of(context).colorScheme.outline,
                    ),
              ),
            ],
          ),
        ),
        if (members.isEmpty)
          Padding(
            padding: const EdgeInsets.all(16),
            child: Center(
              child: Text(
                'No ${title.toLowerCase()} yet',
                style: TextStyle(
                  color: Theme.of(context).colorScheme.outline,
                ),
              ),
            ),
          )
        else
          ListView.builder(
            shrinkWrap: true,
            physics: const NeverScrollableScrollPhysics(),
            itemCount: members.length,
            itemBuilder: (context, index) {
              final member = members[index];
              final bankingName = member['bankingName'] as String?;
              final paymentAmount = member['paymentAmount'] as double?;
              final paymentNote =
                  member['paymentNotes']?[selectedMonth] as String?;

              return Padding(
                padding: const EdgeInsets.symmetric(horizontal: 8, vertical: 4),
                child: Material(
                  borderRadius: BorderRadius.circular(12),
                  color: Theme.of(context).colorScheme.surface,
                  child: InkWell(
                    borderRadius: BorderRadius.circular(12),
                    onTap: () => _showMemberActions(member),
                    child: Padding(
                      padding: const EdgeInsets.all(12),
                      child: Row(
                        children: [
                          Container(
                            width: 40,
                            height: 40,
                            decoration: BoxDecoration(
                              color: Theme.of(context)
                                  .colorScheme
                                  .primaryContainer,
                              shape: BoxShape.circle,
                            ),
                            child: Center(
                              child: Text(
                                member['name'][0].toUpperCase(),
                                style: TextStyle(
                                  color: Theme.of(context)
                                      .colorScheme
                                      .onPrimaryContainer,
                                  fontWeight: FontWeight.bold,
                                ),
                              ),
                            ),
                          ),
                          const SizedBox(width: 12),
                          Expanded(
                            child: Column(
                              crossAxisAlignment: CrossAxisAlignment.start,
                              children: [
                                Text(
                                  member['name'],
                                  style: const TextStyle(
                                    fontWeight: FontWeight.w600,
                                  ),
                                ),
                                if (bankingName != null ||
                                    paymentAmount != null)
                                  const SizedBox(height: 2),
                                if (bankingName != null ||
                                    paymentAmount != null)
                                  Text(
                                    [
                                      if (bankingName != null) bankingName,
                                      if (paymentAmount != null)
                                        'Rs.${paymentAmount.toStringAsFixed(0)}',
                                    ].join('  '),
                                    style: Theme.of(context)
                                        .textTheme
                                        .bodySmall
                                        ?.copyWith(
                                          color: Theme.of(context)
                                              .colorScheme
                                              .outline,
                                        ),
                                  ),
                                const SizedBox(height: 2),
                                Text(
                                  member['phoneNumber'],
                                  style: Theme.of(context)
                                      .textTheme
                                      .bodySmall
                                      ?.copyWith(
                                        color: Theme.of(context)
                                            .colorScheme
                                            .outline,
                                      ),
                                ),
                                if (paymentNote != null) ...[
                                  const SizedBox(height: 4),
                                  Container(
                                    padding: const EdgeInsets.symmetric(
                                        horizontal: 8, vertical: 2),
                                    decoration: BoxDecoration(
                                      color: Theme.of(context)
                                          .colorScheme
                                          .primaryContainer
                                          .withOpacity(0.5),
                                      borderRadius: BorderRadius.circular(4),
                                    ),
                                    child: Text(
                                      paymentNote,
                                      style: Theme.of(context)
                                          .textTheme
                                          .bodySmall
                                          ?.copyWith(
                                            color: Theme.of(context)
                                                .colorScheme
                                                .onPrimaryContainer,
                                          ),
                                    ),
                                  ),
                                ],
                              ],
                            ),
                          ),
                          IconButton(
                            icon: Icon(
                              Icons.more_vert,
                              color: Theme.of(context).colorScheme.outline,
                            ),
                            onPressed: () => _showMemberActions(member),
                          ),
                        ],
                      ),
                    ),
                  ),
                ),
              );
            },
          ),
      ],
    );
  }

  void _showMemberActions(DocumentSnapshot member) {
    final bool isPaid = member['payments'][selectedMonth] ?? false;

    showModalBottomSheet(
      context: context,
      builder: (context) => SafeArea(
        child: Column(
          mainAxisSize: MainAxisSize.min,
          children: [
            Padding(
              padding: const EdgeInsets.all(16),
              child: Row(
                children: [
                  Container(
                    width: 40,
                    height: 40,
                    decoration: BoxDecoration(
                      color: Theme.of(context).colorScheme.primaryContainer,
                      shape: BoxShape.circle,
                    ),
                    child: Center(
                      child: Icon(
                        Icons.album,
                        color: Theme.of(context).colorScheme.onPrimaryContainer,
                      ),
                    ),
                  ),
                  const SizedBox(width: 12),
                  Expanded(
                    child: Column(
                      crossAxisAlignment: CrossAxisAlignment.start,
                      children: [
                        Text(
                          member['name'],
                          style: const TextStyle(
                            fontWeight: FontWeight.w600,
                            fontSize: 16,
                          ),
                        ),
                        Text(
                          member['phoneNumber'],
                          style: Theme.of(context)
                              .textTheme
                              .bodySmall
                              ?.copyWith(
                                color: Theme.of(context).colorScheme.outline,
                              ),
                        ),
                      ],
                    ),
                  ),
                ],
              ),
            ),
            const Divider(),
            ListTile(
              leading: Icon(
                isPaid ? Icons.check_circle : Icons.check_circle_outline,
                color: isPaid ? Colors.green : null,
              ),
              title: Text(isPaid ? 'Mark as Unpaid' : 'Mark as Paid'),
              onTap: () {
                Navigator.pop(context);
                if (!isPaid) {
                  _showPaymentNoteDialog(member);
                } else {
                  _togglePaymentStatus(member, note: null);
                }
              },
            ),
            ListTile(
              leading: const Icon(Icons.edit),
              title: const Text('Edit Member'),
              onTap: () {
                Navigator.pop(context);
                _showEditMemberDialog(member);
              },
            ),
            ListTile(
              leading: const Icon(Icons.delete, color: Colors.red),
              title: const Text('Delete Member',
                  style: TextStyle(color: Colors.red)),
              onTap: () {
                Navigator.pop(context);
                _deleteMember(member);
              },
            ),
            const SizedBox(height: 8),
          ],
        ),
      ),
    );
  }

  void _showPaymentNoteDialog(DocumentSnapshot member) {
    final TextEditingController noteController = TextEditingController();

    showDialog(
      context: context,
      builder: (context) => AlertDialog(
        title: const Text('Payment Note'),
        content: Column(
          mainAxisSize: MainAxisSize.min,
          crossAxisAlignment: CrossAxisAlignment.start,
          children: [
            TextField(
              controller: noteController,
              decoration: const InputDecoration(
                hintText: 'Enter payment details (optional)',
                helperText: 'e.g., Paid by cash, UPI, etc.',
              ),
              maxLines: 2,
            ),
          ],
        ),
        actions: [
          TextButton(
            onPressed: () => Navigator.pop(context),
            child: const Text('Cancel'),
          ),
          FilledButton(
            onPressed: () {
              Navigator.pop(context);
              _togglePaymentStatus(
                member,
                note: noteController.text.trim().isNotEmpty
                    ? noteController.text.trim()
                    : 'Manually marked as paid',
              );
            },
            child: const Text('Mark as Paid'),
          ),
        ],
      ),
    );
  }

  void _togglePaymentStatus(DocumentSnapshot member, {String? note}) async {
    final bool currentStatus = member['payments'][selectedMonth] ?? false;
    final bool newStatus = !currentStatus;

    final Map<String, dynamic> updateData = {
      'payments.$selectedMonth': newStatus,
      if (newStatus) 'forwarded': false,
    };

    // Add or remove payment note
    if (newStatus && note != null) {
      updateData['paymentNotes.$selectedMonth'] = note;
    } else if (!newStatus) {
      updateData['paymentNotes.$selectedMonth'] = FieldValue.delete();
    }

    await member.reference.update(updateData).then((_) {
      // Fetch pending members after payment status is updated
      _fetchPendingMembers();
    });
  }

  void _handleMemberAction(String action, DocumentSnapshot member) {
    switch (action) {
      case 'edit':
        _showEditMemberDialog(member);
        break;
      case 'delete':
        _deleteMember(member);
        break;
    }
  }
}
